/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2010
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   image_sensor_OV5640.c
 *
 * Project:
 * --------
 *   Maui_sw
 *
 * Description:
 * ------------
 *   Image sensor driver function
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "drv_comm.h"
#include "isp_comm_if.h"
#include "camera_sccb.h"
#include "image_sensor.h"
#include "cal_comm_def.h"
#include "isp_if.h"

static struct
{
    kal_bool BypassAe;
    kal_bool BypassAwb;
    kal_bool CapState; /* KAL_TRUE: in capture state, else in preview state */
    kal_bool PvMode; /* KAL_TRUE: preview size output, else full size output */
    kal_uint8 BandingFreq; /* OV5640_50HZ or OV5640_60HZ for 50Hz/60Hz */
    kal_uint32 InternalClock; /* internal clock which using process pixel(for exposure) */
    kal_uint32 Pclk; /* output clock which output to baseband */
    kal_uint32 Gain; /* base on 0x40 */
    kal_uint32 Shutter; /* unit is (linelength / internal clock) s */
    kal_uint32 FrameLength; /* total line numbers in one frame(include dummy line) */
    kal_uint32 LineLength; /* total pixel numbers in one line(include dummy pixel) */
    IMAGE_SENSOR_INDEX_ENUM SensorIdx;
    sensor_data_struct *NvramData;
    kal_uint16 ImageWidth;
    kal_uint16 ImageHeight;
    kal_uint16 ZoomFactor;
    CAL_CAMERA_AF_OPERATION_MODE_ENUM AfMode;
    CAL_CAMERA_GET_AF_ZONE_STRUCT AfZone;
} OV5640Sensor;

#if (defined(__CATS_SUPPORT__)||defined(__ATA_SUPPORT__))
const unsigned char CATSTestPattern[] = { 0 };
#endif

#ifdef OV5640_LOAD_FROM_T_FLASH
/*************************************************************************
* FUNCTION
*  OV5640_Initialize_from_T_Flash
*
* DESCRIPTION
*  Read the initialize setting from t-flash or user disk to speed up image quality tuning.
*
* PARAMETERS
*  None
*
* RETURNS
*  kal_uint8 - 0 : Load setting fail, 1 : Load setting successfully.
*
*************************************************************************/
static kal_uint8 OV5640_Initialize_from_T_Flash()
{
#include <stdlib.h>
#include "med_utility.h"
#include "fs_type.h"

#if OV5640_I2C_ADDR_BITS == CAMERA_SCCB_16BIT
    #define OV5640_REG_SKIP    0x08
#else
    #define OV5640_REG_SKIP    0x06
#endif
#if OV5640_I2C_DATA_BITS == CAMERA_SCCB_16BIT
    #define OV5640_VAL_SKIP    0x08
#else
    #define OV5640_VAL_SKIP    0x06
#endif
  
    /* 0 - Initial value, 1 - Register, 2 - Delay, 3 - End of setting. */
    #define OV5640_OP_CODE_INI    0x00    /* Initial value. */
    #define OV5640_OP_CODE_REG    0x01    /* Register */
    #define OV5640_OP_CODE_DLY    0x02    /* Delay */
    #define OV5640_OP_CODE_END    0x03    /* End of initial setting. */

    typedef struct
    {
        kal_uint16 init_reg;
        kal_uint16 init_val;  /* Save the register value and delay tick */
        kal_uint8 op_code;    /* 0 - Initial value, 1 - Register, 2 - Delay, 3 - End of setting. */
    } OV5640_initial_set_struct;
  
    static OV5640_initial_set_struct OV5640_Init_Reg[1000];
    static WCHAR OV5640_set_file_name[256] = {0};
    FS_HANDLE fp = -1;        /* Default, no file opened. */
    kal_uint8 *data_buff = NULL;
    kal_uint8 *curr_ptr = NULL;
    kal_uint32 file_size = 0;
    kal_uint32 bytes_read = 0;
    kal_uint32 i = 0, j = 0;
    kal_uint8 func_ind[3] = {0};  /* REG or DLY */
    
    kal_mem_cpy(OV5640_set_file_name, L"C:\\OV5640_Initialize_Setting.Bin", sizeof(L"C:\\OV5640_Initialize_Setting.Bin"));
    
    /* Search the setting file in all of the user disk. */
    curr_ptr = (kal_uint8 *)OV5640_set_file_name;
    while (fp < 0)
    {
        if ((*curr_ptr >= 'c' && *curr_ptr <= 'z') || (*curr_ptr >= 'C' && *curr_ptr <= 'Z'))
        {
            fp = FS_Open(OV5640_set_file_name, FS_READ_ONLY);
            if (fp >= 0)
            {
                break; /* Find the setting file. */
            }
            *curr_ptr = *curr_ptr + 1;
        }
        else
        {
            break ;
        }
    }
    if (fp < 0)    /* Error handle */
    {
        OV5640_TRACE("!!! Warning, Can't find the initial setting file!!!");
        return 0;
    }
    
    FS_GetFileSize(fp, &file_size);
    if (file_size < 20)
    {
        OV5640_TRACE("!!! Warning, Invalid setting file!!!");
        return 0;      /* Invalid setting file. */
    }
    
    data_buff = med_alloc_ext_mem(file_size);
    if (data_buff == NULL)
    {
        OV5640_TRACE("!!! Warning, Memory not enoughed...");
        return 0;        /* Memory not enough */
    }
    FS_Read(fp, data_buff, file_size, &bytes_read);
    
    /* Start parse the setting witch read from t-flash. */
    curr_ptr = data_buff;
    while (curr_ptr < (data_buff + file_size))
    {
        while ((*curr_ptr == ' ') || (*curr_ptr == '\t'))/* Skip the Space & TAB */
            curr_ptr++;
        if (((*curr_ptr) == '/') && ((*(curr_ptr + 1)) == '*'))
        {
            while (!(((*curr_ptr) == '*') && ((*(curr_ptr + 1)) == '/')))
            {
                curr_ptr++;    /* Skip block comment code. */
            }
            while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
            {
                curr_ptr++;
            }
            curr_ptr += 2;            /* Skip the enter line */
            continue ;
        }
    
        if (((*curr_ptr) == '/') || ((*curr_ptr) == '{') || ((*curr_ptr) == '}'))    /* Comment line, skip it. */
        {
            while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
            {
                curr_ptr++;
            }

            curr_ptr += 2;            /* Skip the enter line */

            continue ;
        }
        /* This just content one enter line. */
        if (((*curr_ptr) == 0x0D) && ((*(curr_ptr + 1)) == 0x0A))
        {
            curr_ptr += 2;
            continue ;
        }

        kal_mem_cpy(func_ind, curr_ptr, 3);
        curr_ptr += 4;          /* Skip "REG(" or "DLY(" */
        if (strcmp((const char *)func_ind, "REG") == 0)    /* REG */
        {
            OV5640_Init_Reg[i].op_code = OV5640_OP_CODE_REG;
      
            OV5640_Init_Reg[i].init_reg = strtol((const char *)curr_ptr, NULL, 16);
            curr_ptr += OV5640_REG_SKIP;  /* Skip "0x0000, " */
      
            OV5640_Init_Reg[i].init_val = strtol((const char *)curr_ptr, NULL, 16);
            curr_ptr += OV5640_VAL_SKIP;  /* Skip "0x0000);" */
        }
        else                  /* DLY */
        {
            /* Need add delay for this setting. */
            OV5640_Init_Reg[i].op_code = OV5640_OP_CODE_DLY;
      
            OV5640_Init_Reg[i].init_reg = 0xFF;
            OV5640_Init_Reg[i].init_val = strtol((const char *)curr_ptr, NULL, 10);  /* Get the delay ticks, the delay should less then 50 */
        }
        i++;
    
        /* Skip to next line directly. */
        while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
        {
            curr_ptr++;
        }
        curr_ptr += 2;
    }

    /* (0xFFFF, 0xFFFF) means the end of initial setting. */
    OV5640_Init_Reg[i].op_code = OV5640_OP_CODE_END;
    OV5640_Init_Reg[i].init_reg = 0xFF;
    OV5640_Init_Reg[i].init_val = 0xFF;
    i++;

    OV5640_TRACE("%d register read...", i - 1);
    med_free_ext_mem((void **)&data_buff);
    FS_Close(fp);

    OV5640_TRACE("Start apply initialize setting.");
    /* Start apply the initial setting to sensor. */
    for (j=0; j<i; j++)
    {
        if (OV5640_Init_Reg[j].op_code == OV5640_OP_CODE_END)  /* End of the setting. */
        {
            break ;
        }
        else if (OV5640_Init_Reg[j].op_code == OV5640_OP_CODE_DLY)
        {
            kal_sleep_task(OV5640_Init_Reg[j].init_val);    /* Delay */
        }
        else if (OV5640_Init_Reg[j].op_code == OV5640_OP_CODE_REG)
        {
            CamWriteCmosSensor(OV5640_Init_Reg[j].init_reg, OV5640_Init_Reg[j].init_val);
        }
        else
        {
            ASSERT(0);
        }
    }
    OV5640_TRACE("%d register applied...", j);
    return 1;  
}
#endif

/*************************************************************************
* FUNCTION
*   OV5640SetMirror
*
* DESCRIPTION
*   This function set the mirror to the CMOS sensor
*   IMPORTANT NOTICE:
*     the color should be normal when mirror or flip
*
* PARAMETERS
*   Mirror
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640SetMirror(kal_uint8 Mirror)
{
    // TODO: set mirror&flip here
    kal_uint8 TimeCtrl, TimeCtrl1;

    TimeCtrl1 = CamReadCmosSensor(0x3820)&0xF9;
    TimeCtrl = CamReadCmosSensor(0x3821)&0xF9;
    switch (Mirror)
    {
    case IMAGE_SENSOR_MIRROR_NORMAL:
        TimeCtrl |= 0x06;
        break;
    case IMAGE_SENSOR_MIRROR_H:
        /* set nothing in H mirror */
        break;
    case IMAGE_SENSOR_MIRROR_V:
        TimeCtrl |= 0x06;
        TimeCtrl1 |= 0x06;
        break;
    case IMAGE_SENSOR_MIRROR_HV:
        TimeCtrl1 |= 0x06;
        break;
    default:
        TimeCtrl |= 0x06; /* default set to normal */
        break;
    }
    CamWriteCmosSensor(0x3820, TimeCtrl1);
    CamWriteCmosSensor(0x3821, TimeCtrl);
}

/*************************************************************************
* FUNCTION
*   OV5640SetClock
*
* DESCRIPTION
*   This function set sensor internal clock and output clock
*
* PARAMETERS
*   Clk: internal clock
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640SetClock(kal_uint32 InternalClock)
{
    if (OV5640Sensor.InternalClock == InternalClock)
    {
        return;
    }
    OV5640Sensor.InternalClock = InternalClock;
    // TODO: set internal clock(use process pixel) and output clock(ouput to baseband) here
    {
        /* VCO = MCLK * PLL multiplier / pre_div, where
                PLL multiplier = 0x3036[7:0]
                pre_div = 0x3037[3:0]
            internal clock = SYS CLK = VCO / (sys_div * pll_rdiv * bit_div * sclk_rdiv) <= 96MHz, where
                sys_div = 0x3035[7:4]
                pll_rdiv = 0x3037[4] + 1
                bit_div = 0x3034[3:0] / 4 if (0x3034[3:0] == 8 || 0x3034[3:0] == 10) else bit_div = 1
                sclk_rdiv = 2^0x3108[1:0]
            PCLK = VCO / (sys_div * pll_rdiv * bit_div * pclk_rdiv * scale_div * mipi_div) <= 96MHz, where
                pclk_rdiv = 2^0x3108[5:4]
                scale_div = 0x3824[4:0], should be: 1, 2, 4, 8, 16
                mipi_div = 0x3035[3:0] if 0x300e[7:5] == 2 else mipi_div = 0x3035[3:0] * 2
        */
        switch (InternalClock)
        {
#if OV5640_MCLK == 24000000
        case 49500000: /* MCLK: 24M, INTERNAL CLK: 49.5M, PCLK: 49.5M for 30fps preview */
            OV5640Sensor.Pclk = 49500000;
            CamWriteCmosSensor(0x3034, 0x18); /* [3:0]: bit_div, should be 0x18 in 24MHz MCLK */
            CamWriteCmosSensor(0x3035, 0x21); /* [7:4]: sys_div, [3:0]: mipi_div */
            CamWriteCmosSensor(0x3036, 0x63); /* PLL multiplier */
            CamWriteCmosSensor(0x3037, 0x13); /* [4]: pll_rdiv, [3:0]: pre_div */
            CamWriteCmosSensor(0x3824, 0x02); /* [4:0]: scale_div */
            break;
        case 48000000: /* MCLK: 24M, INTERNAL CLK: 48M, PCLK: 48M for preview */
            OV5640Sensor.Pclk = 48000000;
            CamWriteCmosSensor(0x3034, 0x18);
            CamWriteCmosSensor(0x3035, 0x21);
            CamWriteCmosSensor(0x3036, 0x60);
            CamWriteCmosSensor(0x3037, 0x13);
            CamWriteCmosSensor(0x3824, 0x02);
            break;
        case 48000001: /* MCLK: 24M, INTERNAL CLK: 48M, PCLK: 96M for capture */
            OV5640Sensor.Pclk = 96000000;
            CamWriteCmosSensor(0x3034, 0x18);
            CamWriteCmosSensor(0x3035, 0x41);
            CamWriteCmosSensor(0x3036, 0x60);
            CamWriteCmosSensor(0x3037, 0x03);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
        case 26000000: /* MCLK: 24M, INTERNAL CLK: 26M, PCLK: 52M for capture */
            OV5640Sensor.Pclk = 52000000;
            CamWriteCmosSensor(0x3034, 0x18);
            CamWriteCmosSensor(0x3035, 0x41);
            CamWriteCmosSensor(0x3036, 0x68);
            CamWriteCmosSensor(0x3037, 0x13);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
        case 24000000: /* MCLK: 24M, INTERNAL CLK: 24M, PCLK: 48M for capture */
            OV5640Sensor.Pclk = 48000000;
            CamWriteCmosSensor(0x3034, 0x18);
            CamWriteCmosSensor(0x3035, 0x41);
            CamWriteCmosSensor(0x3036, 0x60);
            CamWriteCmosSensor(0x3037, 0x13);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
        case 20750000: /* MCLK: 24M, INTERNAL CLK: 20.75M, PCLK: 41.5M for 4x capture */
            OV5640Sensor.Pclk = 41500000;
            CamWriteCmosSensor(0x3034, 0x18);
            CamWriteCmosSensor(0x3035, 0x41);
            CamWriteCmosSensor(0x3036, 0x53);
            CamWriteCmosSensor(0x3037, 0x13);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
        case 10375000: /* MCLK: 24M, INTERNAL CLK: 10.375M, PCLK: 20.75M for 8x capture */
            OV5640Sensor.Pclk = 20750000;
            CamWriteCmosSensor(0x3034, 0x18);
            CamWriteCmosSensor(0x3035, 0x81);
            CamWriteCmosSensor(0x3036, 0x53);
            CamWriteCmosSensor(0x3037, 0x13);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
        default: /* MCLK: 24M, INTERNAL CLK: 24M, PCLK: 48M */
            OV5640_TRACE("clock: %dHz error!!!", InternalClock);
            OV5640Sensor.Pclk = 48000000;
            CamWriteCmosSensor(0x3034, 0x18);
            CamWriteCmosSensor(0x3035, 0x41);
            CamWriteCmosSensor(0x3036, 0x60);
            CamWriteCmosSensor(0x3037, 0x13);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
#else
        case 49688889: /* MCLK: 26M, INTERNAL CLK: 49.68M, PCLK: 49.68M for 30fps preview */
            OV5640Sensor.Pclk = 49688889;
            CamWriteCmosSensor(0x3034, 0x1A);
            CamWriteCmosSensor(0x3035, 0x31);
            CamWriteCmosSensor(0x3036, 0x56);
            CamWriteCmosSensor(0x3037, 0x03);
            CamWriteCmosSensor(0x3824, 0x02);
            break;
        case 47960000: /* MCLK: 26M, INTERNAL CLK: 47.96M, PCLK: 47.96M for preview */
            OV5640Sensor.Pclk = 47960000;
            CamWriteCmosSensor(0x3034, 0x1A);
            CamWriteCmosSensor(0x3035, 0x31);
            CamWriteCmosSensor(0x3036, 0x53);
            CamWriteCmosSensor(0x3037, 0x03);
            CamWriteCmosSensor(0x3824, 0x02);
            break;
        case 47960001: /* MCLK: 26M, INTERNAL CLK: 47.96M, PCLK: 95.9M for capture */
            OV5640Sensor.Pclk = 95900000;
            CamWriteCmosSensor(0x3034, 0x1A);
            CamWriteCmosSensor(0x3035, 0x31);
            CamWriteCmosSensor(0x3036, 0x53);
            CamWriteCmosSensor(0x3037, 0x03);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
        case 26000000: /* MCLK: 26M, INTERNAL CLK: 26M, PCLK: 52M for capture */
            OV5640Sensor.Pclk = 52000000;
            CamWriteCmosSensor(0x3034, 0x1A);
            CamWriteCmosSensor(0x3035, 0x31);
            CamWriteCmosSensor(0x3036, 0x5A);
            CamWriteCmosSensor(0x3037, 0x13);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
        case 23980000: /* MCLK: 26M, INTERNAL CLK: 23.98M, PCLK: 47.96M for capture */
            OV5640Sensor.Pclk = 47960000;
            CamWriteCmosSensor(0x3034, 0x1A);
            CamWriteCmosSensor(0x3035, 0x31);
            CamWriteCmosSensor(0x3036, 0x53);
            CamWriteCmosSensor(0x3037, 0x13);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
        case 20800000: /* MCLK: 26M, INTERNAL CLK: 20.8M, PCLK: 41.6M */
            OV5640Sensor.Pclk = 41600000;
            CamWriteCmosSensor(0x3034, 0x1A);
            CamWriteCmosSensor(0x3035, 0x31);
            CamWriteCmosSensor(0x3036, 0x48);
            CamWriteCmosSensor(0x3037, 0x13);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
        case 10400000: /* MCLK: 26M, INTERNAL CLK: 10.4M, PCLK: 20.8M */
            OV5640Sensor.Pclk = 20800000;
            CamWriteCmosSensor(0x3034, 0x1A);
            CamWriteCmosSensor(0x3035, 0x61);
            CamWriteCmosSensor(0x3036, 0x48);
            CamWriteCmosSensor(0x3037, 0x13);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
        default: /* MCLK: 26M, INTERNAL CLK: 23.98M, PCLK: 47.96M */
            OV5640_TRACE("clock: %dHz error!!!", InternalClock);
            OV5640Sensor.Pclk = 47960000;
            CamWriteCmosSensor(0x3034, 0x1A);
            CamWriteCmosSensor(0x3035, 0x31);
            CamWriteCmosSensor(0x3036, 0x53);
            CamWriteCmosSensor(0x3037, 0x13);
            CamWriteCmosSensor(0x3824, 0x01);
            break;
#endif
        }
    }
}

/*************************************************************************
* FUNCTION
*   OV5640WriteShutter
*
* DESCRIPTION
*   This function apply shutter to sensor
*
* PARAMETERS
*   Shutter: integration time, unit: (linelength / internal clock) s
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640WriteShutter(kal_uint32 Shutter)
{
    // TODO: set integration time here
    const kal_uint16 ShutterLimit = Shutter + OV5640_SHUTTER_MARGIN;
    kal_uint16 ExtraShutter = 0;

    if (ShutterLimit > OV5640Sensor.FrameLength)
    {
        ExtraShutter = ShutterLimit - OV5640Sensor.FrameLength;
    }
    CamWriteCmosSensor(0x350C, ExtraShutter >> 8); /* AEC VTS output */
    CamWriteCmosSensor(0x350D, ExtraShutter);
    Shutter <<= 4; /* low 4bits base on 1/16 line */
    CamWriteCmosSensor(0x3500, Shutter >> 16); /* shutter */
    CamWriteCmosSensor(0x3501, Shutter >> 8);
    CamWriteCmosSensor(0x3502, Shutter);
}

/*************************************************************************
* FUNCTION
*   OV5640ReadShutter
*
* DESCRIPTION
*   This function get shutter from sensor
*
* PARAMETERS
*   None
*
* RETURNS
*   Shutter: integration time, unit: (linelength / internal clock) s
*
* LOCAL AFFECTED
*
*************************************************************************/
static kal_uint32 OV5640ReadShutter(void)
{
    // TODO: read integration time here
    kal_uint32 Shutter;
    
    Shutter = (CamReadCmosSensor(0x3500) << 16)|(CamReadCmosSensor(0x3501) << 8)|CamReadCmosSensor(0x3502);

    return (Shutter >> 4); /* low 4bits base on 1/16 line */
}

/*************************************************************************
* FUNCTION
*   OV5640WriteGain
*
* DESCRIPTION
*   This function apply global gain to sensor
*
* PARAMETERS
*   Gain: base on 0x40
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640WriteGain(kal_uint32 Gain)
{
    // TODO: set global gain here
    kal_uint8 Reg = 0;

    if (Gain > 32 * 0x40 - 0x04) /* max 31.0.9375x */
    {
        ASSERT(0);
    }
    while (Gain >= 0x40 * 2)
    {
        Reg <<= 1;
        Reg |= 0x01;
        Gain >>= 1;
    }
    Reg <<= 4;
    if (Gain >= 0x40)
    {
        Reg |= ((Gain - 0x40) >> 2);
    }
    CamWriteCmosSensor(0x350B, Reg);
}

/*************************************************************************
* FUNCTION
*   OV5640ReadGain
*
* DESCRIPTION
*   This function get global gain from sensor
*
* PARAMETERS
*   None
*
* RETURNS
*   Gain: base on 0x40
*
* LOCAL AFFECTED
*
*************************************************************************/
static kal_uint32 OV5640ReadGain(void)
{
    // TODO: read global gain here
    const kal_uint8 Reg = CamReadCmosSensor(0x350B);

    return (((Reg&0x0F) << 2) + 0x40) * (1 + (Reg >> 4));
}

/*************************************************************************
* FUNCTION
*   OV5640AeEnable
*
* DESCRIPTION
*   disable/enable AE
*
* PARAMETERS
*   Enable
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640AeEnable(kal_bool Enable)
{
    if (OV5640Sensor.BypassAe)
    {
        Enable = KAL_FALSE;
    }
    // TODO: enable or disable AE here
    {
        kal_uint8 AecCtrl;

        AecCtrl = CamReadCmosSensor(0x3503);
        if (Enable)
        {
            AecCtrl &= 0xF8;
        }
        else
        {
            AecCtrl |= 0x07;
        }
        CamWriteCmosSensor(0x3503, AecCtrl);
    }
}

/*************************************************************************
* FUNCTION
*   OV5640AwbEnable
*
* DESCRIPTION
*   disable/enable awb
*
* PARAMETERS
*   Enable
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640AwbEnable(kal_bool Enable)
{
    if (OV5640Sensor.BypassAwb)
    {
        Enable = KAL_FALSE;
    }
    // TODO: enable or disable AWB here
    {
        kal_uint8 AwbCtrl;

        AwbCtrl = CamReadCmosSensor(0x3406);
        if (Enable)
        {
            AwbCtrl &= 0xFE;
        }
        else
        {
            AwbCtrl |= 0x01;
        }
        CamWriteCmosSensor(0x3406, AwbCtrl);
    }
}

/*************************************************************************
* FUNCTION
*    OV5640SetBandingStep
*
* DESCRIPTION
*    This function set base shutter or banding step to the CMOS sensor
*
* PARAMETERS
*    None
*
* RETURNS
*    None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640SetBandingStep(void)
{
    // TODO: set banding step here
    kal_uint16 BandStep50, BandStep60;
    kal_uint32 Tmp;

    Tmp = OV5640Sensor.LineLength * OV5640_50HZ;
    BandStep50 = (OV5640Sensor.InternalClock + (Tmp >> 1)) / Tmp;
    Tmp = OV5640Sensor.LineLength * OV5640_60HZ;
    BandStep60 = (OV5640Sensor.InternalClock + (Tmp >> 1)) / Tmp;
    CamWriteCmosSensor(0x3A08, BandStep50 >> 8); /* 50Hz banding step */
    CamWriteCmosSensor(0x3A09, BandStep50);
    CamWriteCmosSensor(0x3A0A, BandStep60 >> 8); /* 60Hz banding step */
    CamWriteCmosSensor(0x3A0B, BandStep60);

    CamWriteCmosSensor(0x3A0E, OV5640Sensor.FrameLength / BandStep50); /* 50Hz max banding in a frame */
    CamWriteCmosSensor(0x3A0D, OV5640Sensor.FrameLength / BandStep60); /* 60Hz max banding in a frame */
}

/*************************************************************************
* FUNCTION
*   OV5640SetDummy
*
* DESCRIPTION
*   This function set the dummy pixels(Horizontal Blanking) & dummy lines(Vertical Blanking), it can be
*   used to adjust the frame rate or gain more time for back-end process.
*
* PARAMETERS
*   DummyPixel
*   DummyLine
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640SetDummy(kal_uint32 DummyPixel, kal_uint32 DummyLine)
{
    kal_uint32 LineLength, FrameLength;

    if (OV5640Sensor.PvMode) /* preview size output mode */
    {
        LineLength = DummyPixel + OV5640_PV_PERIOD_PIXEL_NUMS;
        FrameLength = DummyLine + OV5640_PV_PERIOD_LINE_NUMS;
    }
    else
    {
        LineLength = DummyPixel + OV5640_FULL_PERIOD_PIXEL_NUMS;
        FrameLength = DummyLine + OV5640_FULL_PERIOD_LINE_NUMS;
    }

    // TODO: set linelength/framelength or dummy pixel/line and return right value here
    {
        if (LineLength > 0xFFF) /* register limitation */
        {
            LineLength = 0xFFF;
        }
        CamWriteCmosSensor(0x380C, LineLength >> 8); /* total HW */
        CamWriteCmosSensor(0x380D, LineLength);
        OV5640Sensor.LineLength = LineLength; /* return right line length */

        if (FrameLength > 0xFFF) /* register limitation */
        {
            FrameLength = 0xFFF;
        }
        CamWriteCmosSensor(0x380E, FrameLength >> 8); /* total VH */
        CamWriteCmosSensor(0x380F, FrameLength);
        OV5640Sensor.FrameLength = FrameLength; /* return right frame length */
    }

    /* config banding step or base shutter */
    if (OV5640Sensor.PvMode) /* preview size output mode */
    {
        OV5640SetBandingStep();
    }
}

/*************************************************************************
* FUNCTION
*   OV5640SetMinFps
*
* DESCRIPTION
*   This function calculate & set min frame rate
*
* PARAMETERS
*   Fps: min frame rate, base on OV5640_FPS(x)
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640SetMinFps(kal_uint16 Fps)
{
    // TODO: set max exposure time or max AE index here
    kal_uint16 MaxFrameLength, MaxExposure;

    MaxFrameLength = OV5640Sensor.InternalClock * OV5640_FPS(1) / (Fps * OV5640Sensor.LineLength);
    if (MaxFrameLength < OV5640Sensor.FrameLength) 
    {
        MaxFrameLength = OV5640Sensor.FrameLength;
    }
    MaxExposure = MaxFrameLength - OV5640_SHUTTER_MARGIN;
    CamWriteCmosSensor(0x3A00, 0x7C); /* AEC CTRL: not fix frame rate */
    CamWriteCmosSensor(0x3A14, MaxExposure >> 8); /* 50Hz max exposure output limit */
    CamWriteCmosSensor(0x3A15, MaxExposure);
    CamWriteCmosSensor(0x3A02, MaxExposure >> 8); /* 60Hz max exposure output limit */
    CamWriteCmosSensor(0x3A03, MaxExposure);
}

/*************************************************************************
* FUNCTION
*   OV5640SetMaxFps
*
* DESCRIPTION
*   This function calculate & set max frame rate
*
* PARAMETERS
*   Fps: max frame rate, base on OV5640_FPS(x)
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640SetMaxFps(kal_uint16 Fps)
{
    kal_uint32 LineLength, FrameLength;

    /* get max line length */
    LineLength = OV5640Sensor.InternalClock * OV5640_FPS(1) / (Fps * OV5640_PV_PERIOD_LINE_NUMS);
    if (LineLength > OV5640_MAX_PV_LINELENGTH) /* overflow check */
    {
        LineLength = OV5640_MAX_PV_LINELENGTH;
    }
    if (LineLength < OV5640_PV_PERIOD_PIXEL_NUMS)
    {
        LineLength = OV5640_PV_PERIOD_PIXEL_NUMS;
    }

    /* get frame height */
    FrameLength = OV5640Sensor.InternalClock * OV5640_FPS(1) / (Fps * LineLength);
    if (FrameLength > OV5640_MAX_PV_FRAMELENGTH) /* overflow check */
    {
        FrameLength = OV5640_MAX_PV_FRAMELENGTH;
    }
    if (FrameLength < OV5640_PV_PERIOD_LINE_NUMS)
    {
        FrameLength = OV5640_PV_PERIOD_LINE_NUMS;
    }

    /* limit max frame rate to Fps specified */
    OV5640SetDummy(LineLength - OV5640_PV_PERIOD_PIXEL_NUMS, FrameLength - OV5640_PV_PERIOD_LINE_NUMS);
}

/*************************************************************************
* FUNCTION
*   OV5640SetVideoFps
*
* DESCRIPTION
*   This function calculate & fix frame rate in video mode
*
* PARAMETERS
*   Fps: target frame rate to fixed, base on OV5640_FPS(x)
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640SetVideoFps(kal_uint16 Fps)
{
    /* limit max frame rate */
    OV5640SetMaxFps(Fps);

    // TODO: fix, set max exposure time or max AE index here
    {
        OV5640SetMinFps(Fps);
        CamWriteCmosSensor(0x3A00, 0x78); /* AEC CTRL: fix frame rate */
    }
}

/*************************************************************************
* FUNCTION
*   OV5640NightMode
*
* DESCRIPTION
*   This function set night mode to sensor.
*
* PARAMETERS
*   Enable
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640NightMode(kal_bool Enable)
{
    // TODO: set night mode here
    if (Enable)
    {
        CamWriteCmosSensor(0x3A18, 0x00); /* gain output top limit = (1 + reg[7:4]) * (1 + reg[3:0] / 16) */
        CamWriteCmosSensor(0x3A19, 0x7C); /* 14x */
    }
    else
    {
        CamWriteCmosSensor(0x3A18, 0x00);
        CamWriteCmosSensor(0x3A19, 0x70); /* 8x */
    }
}

/*************************************************************************
* FUNCTION
*   OV5640Ev
*
* DESCRIPTION
*   Exposure setting.
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640Ev(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        const P_CAL_FEATURE_TYPE_ENUM_STRUCT Exposure = &Out->FeatureInfo.FeatureEnum;

        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_SET_OPERATION|CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_VIDEO_SUPPORT;
        // TODO: add supported EV enum here
        Exposure->IsSupport = KAL_TRUE;
        Exposure->ItemCount = 9;
        Exposure->SupportItem[0] = CAM_EV_NEG_4_3;
        Exposure->SupportItem[1] = CAM_EV_NEG_3_3;
        Exposure->SupportItem[2] = CAM_EV_NEG_2_3;
        Exposure->SupportItem[3] = CAM_EV_NEG_1_3;
        Exposure->SupportItem[4] = CAM_EV_ZERO;
        Exposure->SupportItem[5] = CAM_EV_POS_1_3;
        Exposure->SupportItem[6] = CAM_EV_POS_2_3;
        Exposure->SupportItem[7] = CAM_EV_POS_3_3;
        Exposure->SupportItem[8] = CAM_EV_POS_4_3;
    }
    else if (CAL_FEATURE_SET_OPERATION == In->FeatureCtrlCode)
    {
        // TODO: adjust brightness here
        switch (In->FeatureSetValue)
        {
        case CAM_EV_NEG_4_3:
            CamWriteCmosSensor(0x3A0F, 0x10); /* stable range high limit(enter) */
            CamWriteCmosSensor(0x3A10, 0x08); /* stable range low limit(enter) */
            CamWriteCmosSensor(0x3A1B, 0x10); /* stable range high limit(go out) */
            CamWriteCmosSensor(0x3A1E, 0x08); /* stable range low limit(go out) */
            CamWriteCmosSensor(0x3A11, 0x20); /* step manual mode, fast zone high limit */
            CamWriteCmosSensor(0x3A1F, 0x10); /* step manual mode, fast zone low limit */
            break;
        case CAM_EV_NEG_3_3:
            CamWriteCmosSensor(0x3A0F, 0x18);
            CamWriteCmosSensor(0x3A10, 0x10);
            CamWriteCmosSensor(0x3A1B, 0x18);
            CamWriteCmosSensor(0x3A1E, 0x10);
            CamWriteCmosSensor(0x3A11, 0x30);
            CamWriteCmosSensor(0x3A1F, 0x10);
            break;
        case CAM_EV_NEG_2_3:
            CamWriteCmosSensor(0x3A0F, 0x20);
            CamWriteCmosSensor(0x3A10, 0x18);
            CamWriteCmosSensor(0x3A1B, 0x20);
            CamWriteCmosSensor(0x3A1E, 0x18);
            CamWriteCmosSensor(0x3A11, 0x41);
            CamWriteCmosSensor(0x3A1F, 0x10);
            break;
        case CAM_EV_NEG_1_3:
            CamWriteCmosSensor(0x3A0F, 0x28);
            CamWriteCmosSensor(0x3A10, 0x20);
            CamWriteCmosSensor(0x3A1B, 0x28);
            CamWriteCmosSensor(0x3A1E, 0x20);
            CamWriteCmosSensor(0x3A11, 0x51);
            CamWriteCmosSensor(0x3A1F, 0x10);
            break;
        case CAM_EV_ZERO:
            CamWriteCmosSensor(0x3A0F, 0x30);
            CamWriteCmosSensor(0x3A10, 0x28);
            CamWriteCmosSensor(0x3A1B, 0x30);
            CamWriteCmosSensor(0x3A1E, 0x28);
            CamWriteCmosSensor(0x3A11, 0x61);
            CamWriteCmosSensor(0x3A1F, 0x10);
            break;
        case CAM_EV_POS_1_3:
            CamWriteCmosSensor(0x3A0F, 0x38);
            CamWriteCmosSensor(0x3A10, 0x30);
            CamWriteCmosSensor(0x3A1B, 0x38);
            CamWriteCmosSensor(0x3A1E, 0x30);
            CamWriteCmosSensor(0x3A11, 0x61);
            CamWriteCmosSensor(0x3A1F, 0x10);
            break;
        case CAM_EV_POS_2_3:
            CamWriteCmosSensor(0x3A0F, 0x40);
            CamWriteCmosSensor(0x3A10, 0x38);
            CamWriteCmosSensor(0x3A1B, 0x40);
            CamWriteCmosSensor(0x3A1E, 0x38);
            CamWriteCmosSensor(0x3A11, 0x71);
            CamWriteCmosSensor(0x3A1F, 0x10);
            break;
        case CAM_EV_POS_3_3:
            CamWriteCmosSensor(0x3A0F, 0x48);
            CamWriteCmosSensor(0x3A10, 0x40);
            CamWriteCmosSensor(0x3A1B, 0x48);
            CamWriteCmosSensor(0x3A1E, 0x40);
            CamWriteCmosSensor(0x3A11, 0x80);
            CamWriteCmosSensor(0x3A1F, 0x20);
            break;
        case CAM_EV_POS_4_3:
            CamWriteCmosSensor(0x3A0F, 0x50);
            CamWriteCmosSensor(0x3A10, 0x48);
            CamWriteCmosSensor(0x3A1B, 0x50);
            CamWriteCmosSensor(0x3A1E, 0x48);
            CamWriteCmosSensor(0x3A11, 0x90);
            CamWriteCmosSensor(0x3A1F, 0x20);
            break;
        default:
            return MM_ERROR_SENSOR_FEATURE_NOT_SUPPORT;
        }
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640Contrast
*
* DESCRIPTION
*   Contrast setting.
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640Contrast(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        const P_CAL_FEATURE_TYPE_ENUM_STRUCT Contrast = &Out->FeatureInfo.FeatureEnum;

        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_SET_OPERATION|CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_VIDEO_SUPPORT;
        // TODO: add supported contrast enum here
        Contrast->IsSupport = KAL_TRUE;
        Contrast->ItemCount = 3;
        Contrast->SupportItem[0] = CAM_CONTRAST_HIGH;
        Contrast->SupportItem[1] = CAM_CONTRAST_MEDIUM;
        Contrast->SupportItem[2] = CAM_CONTRAST_LOW;
    }
    else if (CAL_FEATURE_SET_OPERATION == In->FeatureCtrlCode)
    {
        // TODO: adjust contrast here
        switch (In->FeatureSetValue)
        {
        case CAM_CONTRAST_HIGH:
            CamWriteCmosSensor(0x5586, 0x2C);
            CamWriteCmosSensor(0x5585, 0x2C);
            break;
        case CAM_CONTRAST_MEDIUM:
            CamWriteCmosSensor(0x5586, 0x20);
            CamWriteCmosSensor(0x5585, 0x20);
            
            break;
        case CAM_CONTRAST_LOW:
            CamWriteCmosSensor(0x5586, 0x14);
            CamWriteCmosSensor(0x5585, 0x14);
            break;
        default:
            return MM_ERROR_SENSOR_FEATURE_NOT_SUPPORT;
        }
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640Saturation
*
* DESCRIPTION
*   Saturation setting.
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640Saturation(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        const P_CAL_FEATURE_TYPE_ENUM_STRUCT Saturation = &Out->FeatureInfo.FeatureEnum;

        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_SET_OPERATION|CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_VIDEO_SUPPORT;
        // TODO: add supported saturation enum here
        Saturation->IsSupport = KAL_TRUE;
        Saturation->ItemCount = 3;
        Saturation->SupportItem[0] = CAM_SATURATION_HIGH;
        Saturation->SupportItem[1] = CAM_SATURATION_MEDIUM;
        Saturation->SupportItem[2] = CAM_SATURATION_LOW;
    }
    else if (CAL_FEATURE_SET_OPERATION == In->FeatureCtrlCode)
    {
        // TODO: adjust saturation here
        if (CamReadCmosSensor(0x5580)&0x18) /* effect and saturation confilt */
        {
            return MM_ERROR_NONE;
        }
        switch (In->FeatureSetValue)
        {
        case CAM_SATURATION_HIGH:
            CamWriteCmosSensor(0x5583, 0x50);
            CamWriteCmosSensor(0x5584, 0x50);
            break;
        case CAM_SATURATION_MEDIUM:
            CamWriteCmosSensor(0x5583, 0x40);
            CamWriteCmosSensor(0x5584, 0x40);
            break;
        case CAM_SATURATION_LOW:
            CamWriteCmosSensor(0x5583, 0x30);
            CamWriteCmosSensor(0x5584, 0x30);
            break;
        default:
            return MM_ERROR_SENSOR_FEATURE_NOT_SUPPORT;
        }
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640Sharpness
*
* DESCRIPTION
*   Sharpness setting.
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640Sharpness(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        const P_CAL_FEATURE_TYPE_ENUM_STRUCT Sharpness = &Out->FeatureInfo.FeatureEnum;

        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_SET_OPERATION|CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_VIDEO_SUPPORT;
        // TODO: add supported sharpness enum here
        Sharpness->IsSupport = KAL_TRUE;
        Sharpness->ItemCount = 3;
        Sharpness->SupportItem[0] = CAM_SHARPNESS_HIGH;
        Sharpness->SupportItem[1] = CAM_SHARPNESS_MEDIUM;
        Sharpness->SupportItem[2] = CAM_SHARPNESS_LOW;
    }
    else if (CAL_FEATURE_SET_OPERATION == In->FeatureCtrlCode)
    {
        // TODO: adjust sharpness here
        switch (In->FeatureSetValue)
        {
        case CAM_SHARPNESS_HIGH:
            CamWriteCmosSensor(0x5302, 0x08);
            break;
        case CAM_SHARPNESS_MEDIUM:
            CamWriteCmosSensor(0x5302, 0x0C);
            break;
        case CAM_SHARPNESS_LOW:
            CamWriteCmosSensor(0x5302, 0x10);
            break;
        default:
            return MM_ERROR_SENSOR_FEATURE_NOT_SUPPORT;
        }
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640Wb
*
* DESCRIPTION
*   Wb setting.
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640Wb(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        const P_CAL_FEATURE_TYPE_ENUM_STRUCT Wb = &Out->FeatureInfo.FeatureEnum;

        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_SET_OPERATION|CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_VIDEO_SUPPORT;
        // TODO: add supported manual WB enum here
        Wb->IsSupport = KAL_TRUE;
        Wb->ItemCount = 6;
        Wb->SupportItem[0] = CAM_WB_AUTO;
        Wb->SupportItem[1] = CAM_WB_CLOUD;
        Wb->SupportItem[2] = CAM_WB_DAYLIGHT;
        Wb->SupportItem[3] = CAM_WB_INCANDESCENCE;
        Wb->SupportItem[4] = CAM_WB_FLUORESCENT;
        Wb->SupportItem[5] = CAM_WB_TUNGSTEN;
    }
    else if (CAL_FEATURE_SET_OPERATION == In->FeatureCtrlCode)
    {
        // TODO: adjust manual WB here
        switch (In->FeatureSetValue)
        {
        case CAM_WB_AUTO:
            OV5640AwbEnable(KAL_TRUE);
            break;
        case CAM_WB_CLOUD:
            OV5640AwbEnable(KAL_FALSE);
            CamWriteCmosSensor(0x3400, 0x07); /* AWB R gain */
            CamWriteCmosSensor(0x3401, 0x88);
            CamWriteCmosSensor(0x3404, 0x05); /* AWB B gain */
            CamWriteCmosSensor(0x3405, 0x00);
            break;
        case CAM_WB_DAYLIGHT:
            OV5640AwbEnable(KAL_FALSE);
            CamWriteCmosSensor(0x3400, 0x06);
            CamWriteCmosSensor(0x3401, 0x32);
            CamWriteCmosSensor(0x3404, 0x05);
            CamWriteCmosSensor(0x3405, 0x36);
            break;
        case CAM_WB_INCANDESCENCE:
            OV5640AwbEnable(KAL_FALSE);
            CamWriteCmosSensor(0x3400, 0x06);
            CamWriteCmosSensor(0x3401, 0x13);
            CamWriteCmosSensor(0x3404, 0x07);
            CamWriteCmosSensor(0x3405, 0xe2);
            break;
        case CAM_WB_FLUORESCENT:
            OV5640AwbEnable(KAL_FALSE);
            CamWriteCmosSensor(0x3400, 0x06);
            CamWriteCmosSensor(0x3401, 0x13);
            CamWriteCmosSensor(0x3404, 0x07);
            CamWriteCmosSensor(0x3405, 0xe2);
            break;
        case CAM_WB_TUNGSTEN:
            OV5640AwbEnable(KAL_FALSE);
            CamWriteCmosSensor(0x3400, 0x04);
            CamWriteCmosSensor(0x3401, 0x88);
            CamWriteCmosSensor(0x3404, 0x08);
            CamWriteCmosSensor(0x3405, 0xb6);
            break;
        default:
            return MM_ERROR_SENSOR_FEATURE_NOT_SUPPORT;
        }
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640Effect
*
* DESCRIPTION
*   Effect setting.
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640Effect(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        const P_CAL_FEATURE_TYPE_ENUM_STRUCT Effect = &Out->FeatureInfo.FeatureEnum;

        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_SET_OPERATION|CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_VIDEO_SUPPORT;
        // TODO: add supported effect enum here
        Effect->IsSupport = KAL_TRUE;
        Effect->ItemCount = 6;
        Effect->SupportItem[0] = CAM_EFFECT_ENC_NORMAL;
        Effect->SupportItem[1] = CAM_EFFECT_ENC_GRAYSCALE;
        Effect->SupportItem[2] = CAM_EFFECT_ENC_SEPIA;
        Effect->SupportItem[3] = CAM_EFFECT_ENC_SEPIAGREEN;
        Effect->SupportItem[4] = CAM_EFFECT_ENC_SEPIABLUE;
        Effect->SupportItem[5] = CAM_EFFECT_ENC_COLORINV;
    }
    else if (CAL_FEATURE_SET_OPERATION == In->FeatureCtrlCode)
    {
        // TODO: adjust effect here
        kal_uint8 SdeCtrl;
        
        switch (In->FeatureSetValue)
        {
        case CAM_EFFECT_ENC_NORMAL:
            // TODO: contrast and normal confilt 0x5001
            SdeCtrl = CamReadCmosSensor(0x5580)&0x87;
            CamWriteCmosSensor(0x5580, SdeCtrl); /* SDE CTRL */
            CamWriteCmosSensor(0x5583, 0x40); /* saturation */
            CamWriteCmosSensor(0x5584, 0x40);
            break;
        case CAM_EFFECT_ENC_GRAYSCALE:
            SdeCtrl = CamReadCmosSensor(0x5580)&0x87;
            CamWriteCmosSensor(0x5580, SdeCtrl|0x20);
            break;
        case CAM_EFFECT_ENC_SEPIA:
            SdeCtrl = CamReadCmosSensor(0x5580)&0x87;
            CamWriteCmosSensor(0x5580, SdeCtrl|0x18);
            CamWriteCmosSensor(0x5583, 0x40); /* fixed U */
            CamWriteCmosSensor(0x5584, 0xA0); /* fixed V */
            break;
        case CAM_EFFECT_ENC_SEPIAGREEN:
            SdeCtrl = CamReadCmosSensor(0x5580)&0x87;
            CamWriteCmosSensor(0x5580, SdeCtrl|0x18);
            CamWriteCmosSensor(0x5583, 0x60);
            CamWriteCmosSensor(0x5584, 0x60);
            break;
        case CAM_EFFECT_ENC_SEPIABLUE:
            SdeCtrl = CamReadCmosSensor(0x5580)&0x87;
            CamWriteCmosSensor(0x5580, SdeCtrl|0x18);
            CamWriteCmosSensor(0x5583, 0xA0);
            CamWriteCmosSensor(0x5584, 0x40);
            break;
        case CAM_EFFECT_ENC_COLORINV:
            SdeCtrl = CamReadCmosSensor(0x5580)&0x87;
            CamWriteCmosSensor(0x5580, SdeCtrl|0x40);
            break;
        default:
            return MM_ERROR_SENSOR_FEATURE_NOT_SUPPORT;
        }
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640StillCaptureSize
*
* DESCRIPTION
*   This function get capture size
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
MM_ERROR_CODE_ENUM OV5640StillCaptureSize(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    const P_CAL_FEATURE_TYPE_ENUM_STRUCT CapSize = &Out->FeatureInfo.FeatureEnum;

    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_SUPPORT;
        CapSize->IsSupport = KAL_TRUE;
        // TODO: add supported capture size enum here
        CapSize->ItemCount = 7;
        CapSize->SupportItem[0] = CAM_IMAGE_SIZE_WALLPAPER;
        CapSize->SupportItem[1] = CAM_IMAGE_SIZE_VGA;
        CapSize->SupportItem[2] = CAM_IMAGE_SIZE_1M;
        CapSize->SupportItem[3] = CAM_IMAGE_SIZE_2M;
        CapSize->SupportItem[4] = CAM_IMAGE_SIZE_3M;
        CapSize->SupportItem[5] = CAM_IMAGE_SIZE_4M;
        CapSize->SupportItem[6] = CAM_IMAGE_SIZE_5M;
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640Banding
*
* DESCRIPTION
*   This function get banding setting
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640Banding(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    const P_CAL_FEATURE_TYPE_ENUM_STRUCT Banding = &Out->FeatureInfo.FeatureEnum;

    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_SET_OPERATION|CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_VIDEO_SUPPORT;
        Banding->IsSupport = KAL_TRUE;
        Banding->ItemCount = 2;
        Banding->SupportItem[0] = CAM_BANDING_50HZ;
        Banding->SupportItem[1] = CAM_BANDING_60HZ;
    }
    else if (CAL_FEATURE_SET_OPERATION == In->FeatureCtrlCode)
    {
        OV5640Sensor.BandingFreq = (CAM_BANDING_50HZ == In->FeatureSetValue ? OV5640_50HZ : OV5640_60HZ);
        // TODO: set manual banding here
        {
            if (CAM_BANDING_50HZ == In->FeatureSetValue)
            {
                CamWriteCmosSensor(0x3C00, 0x04);
            }
            else
            {
                CamWriteCmosSensor(0x3C00, 0x00);
            }
        }
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640SceneMode
*
* DESCRIPTION
*   This function get/set scene mode of sensor.
*
* PARAMETERS
*   IsCam: camera scene mode or not
*   In, Out
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640SceneMode(kal_bool IsCam, P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        const P_CAL_FEATURE_TYPE_ENUM_STRUCT SceneMode = &Out->FeatureInfo.FeatureEnum;

        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_SET_OPERATION|CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_SUPPORT;
        SceneMode->IsSupport = KAL_TRUE;
        SceneMode->ItemCount = 2;
        if (IsCam)
        {
            SceneMode->SupportItem[0] = CAM_AUTO_DSC;
            SceneMode->SupportItem[1] = CAM_NIGHTSCENE;
        }
        else
        {
            SceneMode->SupportItem[0] = CAM_VIDEO_AUTO;
            SceneMode->SupportItem[1] = CAM_VIDEO_NIGHT;
        }
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640GetZoomInfo
*
* DESCRIPTION
*   This function get sensor zoom info
*
* PARAMETERS
*   Query, Info
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640GetZoomInfo(P_CAL_CAMERA_DIGITAL_ZOOM_IN_STRUCT Query, P_CAL_CAMERA_DIGITAL_ZOOM_OUT_STRUCT Info)
{
    static const kal_uint16 Zoom[][2] =
    { /* TotalZoomSteps, MaxZoomFactor */
        {01,100}, /* not support */
        {40,800}, /* default */
        {24,202}, /* 1M */
        {18,162}, /* 2M */
        {10,126}, /* 3M */
        {05,112}, /* 4M */
    };
    kal_uint8 i = 1;

    if (CAL_SCENARIO_CAMERA_PREVIEW == Query->ScenarioId)
    {
        switch (Query->CameraImageSize)
        {
        case CAM_IMAGE_SIZE_1M:
            i = 2;
            break;
        case CAM_IMAGE_SIZE_2M:
            i = 3;
            break;
        case CAM_IMAGE_SIZE_3M:
            i = 4;
            break;
        case CAM_IMAGE_SIZE_4M:
            i = 5;
            break;
        case CAM_IMAGE_SIZE_5M:
            i = 0;
            break;
        default:
            i = 1;
            break;
        }
    }
    Info->DzType = CAM_DZ_TYPE_RANGE;
    Info->TotalZoomSteps = Zoom[i][0];
    Info->MaxZoomFactor = Zoom[i][1];
    Info->pZoomFactorListTable = NULL;

    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640GetCaptureFormat
*
* DESCRIPTION
*   This function get capture format
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640GetCaptureFormat(P_CAL_CAMERA_DIGITAL_ZOOM_IN_STRUCT Query, P_IMAGE_SENSOR_CAPTURE_FORMAT_STRUCT Info)
{
        Info->DataType = IMAGE_SENSOR_DATA_OUT_FORMAT_YUYV;
}
/*************************************************************************
* FUNCTION
*   OV5640AfSetCmd
*
* DESCRIPTION
*   This function send cmd to AF core
*
* PARAMETERS
*   Cmd: 0x03: trigger auto focus
*        0x07: get focus result
*        0x08: release focus
*        0x12: re-launch zone configuration
*        0x80: launch default zone configuration
*        0x81: set and launch touch mode zone configuration
*        0x8F: enable custom mode zone configuration
*        0x90~4: VVF coordinate: zone0~4
*        0x98: set weight of zones
*        0x9F: launch custom zone configuration
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640AfSetCmd(kal_uint8 Cmd)
{
    kal_uint16 i = 1001;

    CamWriteCmosSensor(0x3023, 0x01);
    CamWriteCmosSensor(0x3022, Cmd);
    while (--i > 0 && CamReadCmosSensor(0x3023))
    {
        kal_sleep_task(1);
    }
    if (!i)
    {
        OV5640_TRACE("AF set cmd: %x time out!!!", Cmd);
    }
}

/*************************************************************************
* FUNCTION
*   OV5640AfGetState
*
* DESCRIPTION
*   This function get auto focus status
*
* PARAMETERS
*   None
*
* RETURNS
*   Status: 0x7F: firmware is downloaded and not run
*           0x7E: firmware is initializing
*           0x70: idle state, focus is released; lens is located at the furthest position
*           0x10: auto focus is completed
*           0x16: configure zoon mode
*           0x00~0x0F, 0x80~0x8F: auto focus is running
*
* LOCAL AFFECTED
*
*************************************************************************/
static kal_uint8 OV5640AfGetState(void)
{
    return CamReadCmosSensor(0x3029);
}

/*************************************************************************
* FUNCTION
*   OV5640AfDefaultZone
*
* DESCRIPTION
*   This function launch default zone configuration
*
* PARAMETERS
*   None
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640AfDefaultZone(void)
{
    OV5640Sensor.AfZone.AfActiveZone = 1;
    OV5640Sensor.AfMode = CAM_AF_SINGLE_ZONE;
    OV5640Sensor.AfZone.AfZoneIsp[0].W = 16 * OV5640_IMAGE_SENSOR_PV_WIDTH / 80;
    OV5640Sensor.AfZone.AfZoneIsp[0].H = 12 * OV5640_IMAGE_SENSOR_PV_HEIGHT / 60;
    OV5640Sensor.AfZone.AfZoneIsp[0].X = 40 * OV5640_IMAGE_SENSOR_PV_WIDTH / 80;
    OV5640Sensor.AfZone.AfZoneIsp[0].Y = 30 * OV5640_IMAGE_SENSOR_PV_HEIGHT / 60;
    OV5640AfSetCmd(0x12); /* re-launch zone configuration */
    OV5640AfSetCmd(0x80); /* default zone configuration */
}

/*************************************************************************
* FUNCTION
*   OV5640AfDefaultZone
*
* DESCRIPTION
*   This function set and launch custom zone configuration
*
* PARAMETERS
*   Size: 5 window size(offset x, offset y, width, height)
*   Weight: 5 window weight
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640AfCustomZone(P_CAL_CAMERA_AF_RECT_STRUCT Size, kal_uint8 *Weight)
{
    kal_uint8 i;

    OV5640AfSetCmd(0x12); /* re-launch zone configuration */
    OV5640AfSetCmd(0x8F); /* enable custom mode zone configuration */
    OV5640Sensor.AfZone.AfActiveZone = 0x1F; /* 0001111b */
    OV5640Sensor.AfMode = CAM_AF_MULTI5_ZONE;
    kal_mem_cpy(OV5640Sensor.AfZone.AfZoneIsp, Size, sizeof(OV5640Sensor.AfZone.AfZoneIsp));
    for (i = 0; i < AF_ZONE_NO; i++)
    {
        CamWriteCmosSensor(0x3024, Size[i].X * 80 / OV5640_IMAGE_SENSOR_PV_WIDTH);
        CamWriteCmosSensor(0x3025, Size[i].Y * 60 / OV5640_IMAGE_SENSOR_PV_HEIGHT);
        CamWriteCmosSensor(0x3026, (Size[i].X + Size[i].W) * 80 / OV5640_IMAGE_SENSOR_PV_WIDTH);
        CamWriteCmosSensor(0x3027, (Size[i].Y + Size[i].H) * 60 / OV5640_IMAGE_SENSOR_PV_HEIGHT);
        /* should no use OV5640AfSetCmd because delay is forbidden for cmd: 0x90~0x94 */
        CamWriteCmosSensor(0x3023, 0x01);
        CamWriteCmosSensor(0x3022, 0x90 + i); /* VVF coordinate: zone0~4 */
    }
    CamWriteCmosSensor(0x3024, Weight[0]);
    CamWriteCmosSensor(0x3025, Weight[1]);
    CamWriteCmosSensor(0x3026, Weight[2]);
    CamWriteCmosSensor(0x3027, Weight[3]);
    CamWriteCmosSensor(0x3028, Weight[4]);
    OV5640AfSetCmd(0x98); /* set weight of zones */
    OV5640AfSetCmd(0x9F); /* launch custom zone configuration */
}

/*************************************************************************
* FUNCTION
*   OV5640AfKey
*
* DESCRIPTION
*   This function do AF operation
*
* PARAMETERS
*   In, AfDelay
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640AfKey(P_CAL_FEATURE_CTRL_STRUCT In, P_SENSOR_AF_DELAY_STRUCT AfDelay)
{
    if (CAL_FEATURE_SET_OPERATION == In->FeatureCtrlCode)
    {
        if (CAM_AF_ONE_TIME == In->FeatureSetValue)
        {
            if ((OV5640AfGetState()&0x7F) > 0x0F)
            {
                AfDelay->type = DELAYFRAME;
                /* because we can get result immediately after send auto focus cmd.
                              In the cmd, it will return until focus done.
                        */
                AfDelay->count = 0;
                //AfDelay->count = 8; /* sensor AF default dealy frame */
                //if (CAM_AF_MULTI5_ZONE == OV5640Sensor.AfMode)
                //{
                //    AfDelay->count = 16;
                //}
                // TODO: send cmd to do auto focus
                OV5640AfSetCmd(0x03); /* trigger auto focus */
            }
        }
        else if (CAM_AF_RELEASE == In->FeatureSetValue)
        {
            // TODO: send cmd to do release focus
            OV5640AfSetCmd(0x08); /* release focus */
        }
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640AfRange
*
* DESCRIPTION
*   This function get AF range
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640AfRange(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        const P_CAL_FEATURE_TYPE_ENUM_STRUCT AfRange = &Out->FeatureInfo.FeatureEnum;

        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_SET_OPERATION|CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_SUPPORT;
#if (!defined(AF_SUPPORT))
        AfRange->IsSupport = KAL_FALSE;
#else
        AfRange->IsSupport = KAL_TRUE;
        AfRange->ItemCount = 1;
        AfRange->SupportItem[0] = CAM_AF_RANGE_AUTO;
#endif
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640AfOperation
*
* DESCRIPTION
*   This function get and set af operation
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640AfOperation(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        const P_CAL_FEATURE_TYPE_ENUM_STRUCT AfOperation = &Out->FeatureInfo.FeatureEnum;

        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_SET_OPERATION|CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_SUPPORT;
#if (!defined(AF_SUPPORT))
        AfOperation->IsSupport = KAL_FALSE;
#else
        AfOperation->IsSupport = KAL_TRUE;
        if (CAL_CAMERA_MODE_VIDEO == In->CameraMode)
        {
            AfOperation->ItemCount = 2;
            AfOperation->SupportItem[0] = CAM_AF_OFF;
            AfOperation->SupportItem[1] = CAM_AF_SINGLE_ZONE;
        }
        else
        {
            AfOperation->ItemCount = 3;
            AfOperation->SupportItem[0] = CAM_AF_OFF;
            AfOperation->SupportItem[1] = CAM_AF_SINGLE_ZONE;
            AfOperation->SupportItem[2] = CAM_AF_MULTI5_ZONE;
        }
#endif
    }
    else if (CAL_FEATURE_SET_OPERATION == In->FeatureCtrlCode)
    {
        switch (In->FeatureSetValue)
        {
        case CAM_AF_OFF:
            OV5640Sensor.AfMode = CAM_AF_OFF;
            OV5640Sensor.AfZone.AfActiveZone = 0;
            break;
        case CAM_AF_SINGLE_ZONE:
            OV5640AfDefaultZone();
            break;
        case CAM_AF_MULTI5_ZONE:
        {
            static CAL_CAMERA_AF_RECT_STRUCT DefAfZoneInfoMulti5[AF_ZONE_NO]=
            {
                {96, 96, 320, 360},
                {96, 96, 320, 120},
                {96, 96, 320, 240},
                {96, 96, 160, 240},
                {96, 96, 480, 240},
            };
            static kal_uint8 AFWeight[] = {8,4,4,4,4};
            
            OV5640AfCustomZone(DefAfZoneInfoMulti5, AFWeight);
            break;
        }
        default:
            OV5640AfDefaultZone();
            break;
        }
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640AfGetZone
*
* DESCRIPTION
*   This function get af zone info
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640AfGetZone(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    if (CAL_FEATURE_GET_OPERATION == In->FeatureCtrlCode)
    {
        Out->FeatureInfo.FeatureStructured.pCamGetAfZoneOutPara = &(OV5640Sensor.AfZone);
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640AfGetResult
*
* DESCRIPTION
*   This function get af result
*
* PARAMETERS
*   In, pAfResult
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640AfGetResult(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_CAMERA_AF_RESULT_STRUCT pAfResult)
{
    if (CAL_FEATURE_GET_OPERATION == In->FeatureCtrlCode)
    {
        kal_uint8 AfState;

        AfState = OV5640AfGetState();
        if (0x10 == AfState) /* auto focus is completed */
        {
            kal_uint8 AfResult = 0;

            OV5640AfSetCmd(0x07); /* get focus result */
            if (!CamReadCmosSensor(0x3024)) AfResult |= 0x01;
            if (!CamReadCmosSensor(0x3025)) AfResult |= 0x02;
            if (!CamReadCmosSensor(0x3026)) AfResult |= 0x04;
            if (!CamReadCmosSensor(0x3027)) AfResult |= 0x08;
            if (!CamReadCmosSensor(0x3028)) AfResult |= 0x10;
            if (CAM_AF_SINGLE_ZONE == OV5640Sensor.AfMode)
            {
                AfResult &= 0x01;
            }
            if (AfResult > 0) /* at lest one focus window */
            {
                pAfResult->AfSearchResult = AF_SEARCH_STATUS_FOUND_SUCCESS;
                pAfResult->AfSuccessZone = AfResult;
            }
            else /* no focus window */
            {
                pAfResult->AfSearchResult = AF_SEARCH_STATUS_FOUND_FAIL;
            }
        }
        else if ((AfState&0x7F) <= 0x0F) /* auto focus is running */
        {
            pAfResult->AfSearchResult = AF_SEARCH_STATUS_BUSY;
        }
        else if (0x70 == AfState) /* idle state, focus is released; lens is located at the furthest position */
        {
            pAfResult->AfSearchResult = AF_SEARCH_STATUS_IDLE;
        }
        else
        {
            pAfResult->AfSearchResult = AF_SEARCH_STATUS_FOUND_FAIL;
        }
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640AfInit
*
* DESCRIPTION
*   This function init AF core and update FW
*
* PARAMETERS
*   In, pAfResult
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640AfInit(void)
{
#if (defined(AF_SUPPORT))
#ifdef __OV5640_SINGLE_ZONE_AF__
    static const kal_uint8 AfFw1p01[] =
    {
        0x02,0x00,0x06,0x02,0x0c,0xff,0x78,0x7f,0xe4,0xf6,0xd8,0xfd,0x75,0x81,0xe4,0x02,
        0x09,0x9e,0x32,0x02,0x00,0x12,0x90,0x38,0x04,0xe0,0xfe,0xa3,0xe0,0xfd,0xee,0xf5,
        0x0f,0xed,0xf5,0x10,0x90,0x38,0x00,0xe0,0xfe,0xa3,0xe0,0xfd,0xed,0xff,0x12,0x09,
        0x52,0x90,0x38,0x10,0x12,0x09,0x89,0x12,0x09,0x52,0x90,0x38,0x06,0xe0,0xfe,0xa3,
        0xe0,0xfd,0xee,0xf5,0x11,0xed,0xf5,0x12,0x90,0x38,0x02,0xe0,0xfe,0xa3,0xe0,0xfd,
        0xed,0xff,0x12,0x09,0x5e,0x90,0x38,0x12,0x12,0x09,0x89,0x12,0x09,0x5e,0xa3,0xe0,
        0xb4,0x31,0x0b,0xe5,0x0f,0xc3,0x13,0xf5,0x0f,0xe5,0x10,0x13,0xf5,0x10,0x90,0x38,
        0x14,0xe0,0xb4,0x71,0x11,0xe5,0x10,0xae,0x0f,0x78,0x02,0xce,0xc3,0x13,0xce,0x13,
        0xd8,0xf9,0xf5,0x10,0x8e,0x0f,0x90,0x38,0x15,0xe0,0xb4,0x31,0x0b,0xe5,0x11,0xc3,
        0x13,0xf5,0x11,0xe5,0x12,0x13,0xf5,0x12,0x90,0x38,0x15,0xe0,0xb4,0x71,0x11,0xe5,
        0x12,0xae,0x11,0x78,0x02,0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,0xf5,0x12,0x8e,0x11,
        0xe5,0x0f,0xc4,0xf8,0x54,0xf0,0xc8,0x68,0xf5,0x0f,0xe5,0x10,0xc4,0x54,0x0f,0x48,
        0xf5,0x10,0xe5,0x11,0xc4,0xf8,0x54,0xf0,0xc8,0x68,0xf5,0x11,0xe5,0x12,0xc4,0x54,
        0x0f,0x48,0xf5,0x12,0xe4,0xfa,0xea,0x70,0x04,0x7f,0x04,0x80,0x02,0x7f,0x03,0x8f,
        0x0d,0xe5,0x0d,0x25,0xe0,0xf5,0x0e,0xea,0x70,0x06,0xae,0x0f,0xaf,0x10,0x80,0x04,
        0xae,0x11,0xaf,0x12,0x8e,0x13,0x8f,0x14,0xe4,0xfb,0xc3,0xe5,0x14,0x95,0x0e,0xe5,
        0x13,0x94,0x00,0x50,0x0e,0xe4,0xf5,0x09,0xf5,0x0a,0x85,0x13,0x0b,0x85,0x14,0x0c,
        0x02,0x02,0x00,0xea,0x70,0x09,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x6d,0x80,0x07,0xeb,
        0x25,0xe0,0x25,0xe0,0x24,0x6e,0xf8,0xe6,0x75,0x09,0x00,0xf5,0x0a,0xae,0x09,0xaf,
        0x0a,0xac,0x13,0xad,0x14,0x12,0x04,0xf3,0x8e,0x09,0x8f,0x0a,0xea,0x70,0x09,0xeb,
        0x25,0xe0,0x25,0xe0,0x24,0x6f,0x80,0x07,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x70,0xf8,
        0xe6,0x75,0x0b,0x00,0xf5,0x0c,0xae,0x0b,0xaf,0x0c,0xac,0x13,0xad,0x14,0x12,0x04,
        0xf3,0x8e,0x0b,0x8f,0x0c,0xea,0xae,0x09,0xaf,0x0a,0x60,0x05,0x90,0x0e,0x62,0x80,
        0x03,0x90,0x0e,0x61,0xe4,0x93,0xfd,0x7c,0x00,0x12,0x05,0x05,0x8e,0x09,0x8f,0x0a,
        0xae,0x0b,0xaf,0x0c,0xe4,0x93,0xfd,0x7c,0x00,0x12,0x05,0x05,0x8e,0x0b,0x8f,0x0c,
        0xc3,0xe5,0x0c,0x95,0x0a,0xff,0xe5,0x0b,0x95,0x09,0xfe,0xc3,0xef,0x95,0x0e,0xee,
        0x94,0x00,0x50,0x5c,0xe5,0x0c,0x25,0x0a,0xff,0xe5,0x0b,0x35,0x09,0xc3,0x13,0xfe,
        0xef,0x13,0xff,0xc3,0x95,0x0d,0xee,0x94,0x00,0x50,0x0c,0xe4,0xf5,0x09,0xf5,0x0a,
        0xf5,0x0b,0x85,0x0e,0x0c,0x80,0x39,0xe5,0x0d,0x2f,0xfd,0xe4,0x3e,0xfc,0xd3,0xed,
        0x95,0x14,0xec,0x95,0x13,0x40,0x14,0x85,0x13,0x0b,0x85,0x14,0x0c,0xe5,0x14,0x95,
        0x0e,0xf5,0x0a,0xe5,0x13,0x94,0x00,0xf5,0x09,0x80,0x15,0xad,0x0d,0x7c,0x00,0xc3,
        0xef,0x9d,0xf5,0x0a,0xee,0x9c,0xf5,0x09,0xed,0x2f,0xf5,0x0c,0xec,0x3e,0xf5,0x0b,
        0xeb,0x75,0xf0,0x08,0xa4,0x24,0x85,0xf8,0xea,0x25,0xe0,0x28,0xf8,0xa6,0x09,0x08,
        0xa6,0x0a,0xeb,0x75,0xf0,0x08,0xa4,0x24,0x89,0xf8,0xea,0x25,0xe0,0x28,0xf8,0xa6,
        0x0b,0x08,0xa6,0x0c,0x0b,0xeb,0x64,0x05,0x60,0x03,0x02,0x00,0xfa,0x0a,0xea,0x64,
        0x02,0x60,0x03,0x02,0x00,0xd6,0xe4,0xfa,0x7b,0x01,0xeb,0x75,0xf0,0x08,0xa4,0x24,
        0x8c,0xf9,0xea,0x12,0x09,0x6a,0xc3,0x97,0xee,0x19,0x97,0x50,0x04,0xaf,0x03,0x80,
        0x02,0xaf,0x02,0xaa,0x07,0x0b,0xbb,0x05,0xe1,0xea,0x60,0x0b,0x12,0x09,0x6a,0xff,
        0x78,0x8b,0xa6,0x06,0x08,0xa6,0x07,0x78,0x86,0xe6,0x90,0x60,0x01,0xf0,0x78,0x88,
        0xe6,0xa3,0xf0,0x78,0x8a,0xe6,0xa3,0xf0,0x78,0x8c,0xe6,0xa3,0xf0,0x78,0x8e,0xe6,
        0xa3,0xf0,0x78,0x90,0xe6,0xa3,0xf0,0x78,0x92,0xe6,0xa3,0xf0,0x78,0x94,0xe6,0xa3,
        0xf0,0x78,0x96,0xe6,0xa3,0xf0,0x78,0x98,0xe6,0xa3,0xf0,0x78,0x9a,0xe6,0xa3,0xf0,
        0x78,0x9c,0xe6,0xa3,0xf0,0x78,0x9e,0xe6,0xa3,0xf0,0x78,0xa0,0xe6,0xa3,0xf0,0x78,
        0xa2,0xe6,0xa3,0xf0,0x78,0xa4,0xe6,0xa3,0xf0,0x78,0xa6,0xe6,0xa3,0xf0,0x78,0xa8,
        0xe6,0xa3,0xf0,0x78,0xaa,0xe6,0xa3,0xf0,0x78,0xac,0xe6,0xa3,0xf0,0x22,0xe4,0xf5,
        0x0d,0x75,0x0e,0xff,0xfb,0x74,0x3b,0x12,0x08,0xb3,0x40,0x28,0x74,0x4d,0x2b,0xf8,
        0xe4,0xf6,0x74,0x3b,0x2b,0xf8,0xe6,0xff,0xe5,0x0e,0xd3,0x9f,0x40,0x02,0x80,0x02,
        0xaf,0x0e,0x8f,0x0e,0xe6,0xff,0xe5,0x0d,0xc3,0x9f,0x50,0x02,0x80,0x02,0xaf,0x0d,
        0x8f,0x0d,0x80,0x06,0x74,0x4d,0x2b,0xf8,0x76,0x01,0x0b,0xbb,0x05,0xc7,0xe4,0xfb,
        0x74,0xe0,0x2b,0xf8,0xe4,0xf6,0x12,0x08,0xb1,0x40,0x03,0x02,0x03,0xb0,0xeb,0x25,
        0xe0,0x24,0x6d,0x12,0x09,0x0d,0x85,0x09,0x0b,0xf5,0x0c,0x74,0xe0,0x2b,0xf8,0xe4,
        0xf6,0x7f,0x01,0x12,0x09,0x16,0xc3,0xe5,0x0a,0x97,0xe5,0x09,0x19,0x97,0x50,0x11,
        0xef,0x12,0x08,0xbb,0xeb,0x25,0xe0,0x28,0x12,0x09,0x0d,0x74,0xe0,0x2b,0xf8,0xa6,
        0x07,0x12,0x09,0x16,0xd3,0xe5,0x0c,0x97,0xe5,0x0b,0x19,0x97,0x40,0x10,0xef,0x12,
        0x08,0xbb,0xeb,0x25,0xe0,0x28,0xf8,0xe6,0xf5,0x0b,0x08,0xe6,0xf5,0x0c,0x0f,0xbf,
        0x05,0xc1,0xeb,0x25,0xe0,0x24,0x9f,0xf8,0xa6,0x09,0x08,0xa6,0x0a,0xae,0x0b,0xaf,
        0x0c,0x90,0x0e,0x83,0xe4,0x93,0xfd,0x7c,0x00,0x12,0x04,0xf3,0x8e,0x0b,0x8f,0x0c,
        0xae,0x09,0xaf,0x0a,0xa3,0xe4,0x93,0xfd,0x12,0x04,0xf3,0x8e,0x09,0x8f,0x0a,0xd3,
        0xe5,0x0c,0x95,0x0a,0xe5,0x0b,0x95,0x09,0x40,0x06,0x74,0x4d,0x2b,0xf8,0x76,0x02,
        0x0b,0xeb,0x64,0x05,0x60,0x03,0x02,0x03,0x10,0xe4,0xf5,0x09,0xf5,0x0a,0xff,0xfb,
        0x12,0x08,0xb1,0x50,0x35,0xef,0x70,0x09,0x74,0xe0,0x2b,0x12,0x09,0x4b,0xff,0x80,
        0x29,0x74,0xe0,0x2b,0xf8,0xe6,0xfe,0x24,0xd1,0xf8,0xe6,0xd3,0x9f,0x40,0x06,0x74,
        0xd1,0x2e,0xf8,0xe6,0xff,0x12,0x09,0x24,0xd3,0xe7,0x95,0x0a,0x19,0xe7,0x95,0x09,
        0x40,0x08,0xeb,0x25,0xe0,0x24,0x9f,0x12,0x09,0x0d,0x0b,0xbb,0x05,0xc2,0xef,0x70,
        0x06,0xf5,0x36,0x75,0x20,0x8e,0x22,0x85,0x0d,0x0c,0x85,0x0e,0x0b,0xe4,0xfb,0x12,
        0x08,0xb1,0x50,0x2c,0x74,0x3b,0x2b,0xf8,0xe6,0xff,0xe5,0x0c,0xd3,0x9f,0x40,0x08,
        0xe5,0x0e,0xd3,0x9f,0x50,0x02,0x80,0x02,0xaf,0x0c,0x8f,0x0c,0xe6,0xff,0xe5,0x0b,
        0xc3,0x9f,0x50,0x08,0xe5,0x0d,0xc3,0x9f,0x40,0x02,0x80,0x02,0xaf,0x0b,0x8f,0x0b,
        0x0b,0xbb,0x05,0xcb,0xe5,0x0b,0x65,0x0e,0x60,0x4e,0xe4,0xfb,0x12,0x08,0xb1,0x50,
        0x18,0x74,0x3b,0x2b,0xf8,0xe6,0xb5,0x0b,0x10,0x12,0x09,0x24,0xe7,0xb5,0x0a,0x09,
        0x19,0xe7,0xb5,0x09,0x04,0x8b,0x4c,0x80,0x4a,0x0b,0xbb,0x05,0xdf,0xe4,0xfb,0x12,
        0x08,0xb1,0x50,0x18,0x74,0x3b,0x2b,0xf8,0xe6,0xb5,0x0b,0x10,0x12,0x09,0x24,0xe7,
        0xb5,0x0a,0x09,0x19,0xe7,0xb5,0x09,0x04,0x8b,0x4c,0x80,0x27,0x0b,0xbb,0x05,0xdf,
        0xe5,0x0b,0x14,0xf5,0x0d,0x02,0x04,0x07,0xe4,0xfb,0x12,0x08,0xb1,0x50,0x10,0x12,
        0x09,0x24,0xe7,0xb5,0x0a,0x09,0x19,0xe7,0xb5,0x09,0x04,0x8b,0x4c,0x80,0x04,0x0b,
        0xbb,0x05,0xe7,0xe4,0xfb,0x12,0x08,0xb1,0x50,0x13,0x74,0xe0,0x25,0x4c,0xf9,0x74,
        0xe0,0x2b,0xf8,0xe6,0x67,0x60,0x06,0x74,0x4d,0x2b,0xf8,0x76,0x03,0x0b,0xbb,0x05,
        0xe4,0x74,0xe0,0x12,0x09,0x49,0xf5,0x36,0x30,0x0b,0x04,0x7f,0xfe,0x80,0x02,0x7f,
        0x02,0x12,0x09,0x7e,0xc3,0x96,0xf5,0x36,0x74,0xd1,0x25,0x20,0xf8,0xa6,0x36,0x75,
        0x20,0x86,0x22,0xef,0x8d,0xf0,0xa4,0xa8,0xf0,0xcf,0x8c,0xf0,0xa4,0x28,0xce,0x8d,
        0xf0,0xa4,0x2e,0xfe,0x22,0xbc,0x00,0x0b,0xbe,0x00,0x29,0xef,0x8d,0xf0,0x84,0xff,
        0xad,0xf0,0x22,0xe4,0xcc,0xf8,0x75,0xf0,0x08,0xef,0x2f,0xff,0xee,0x33,0xfe,0xec,
        0x33,0xfc,0xee,0x9d,0xec,0x98,0x40,0x05,0xfc,0xee,0x9d,0xfe,0x0f,0xd5,0xf0,0xe9,
        0xe4,0xce,0xfd,0x22,0xed,0xf8,0xf5,0xf0,0xee,0x84,0x20,0xd2,0x1c,0xfe,0xad,0xf0,
        0x75,0xf0,0x08,0xef,0x2f,0xff,0xed,0x33,0xfd,0x40,0x07,0x98,0x50,0x06,0xd5,0xf0,
        0xf2,0x22,0xc3,0x98,0xfd,0x0f,0xd5,0xf0,0xea,0x22,0xe8,0x8f,0xf0,0xa4,0xcc,0x8b,
        0xf0,0xa4,0x2c,0xfc,0xe9,0x8e,0xf0,0xa4,0x2c,0xfc,0x8a,0xf0,0xed,0xa4,0x2c,0xfc,
        0xea,0x8e,0xf0,0xa4,0xcd,0xa8,0xf0,0x8b,0xf0,0xa4,0x2d,0xcc,0x38,0x25,0xf0,0xfd,
        0xe9,0x8f,0xf0,0xa4,0x2c,0xcd,0x35,0xf0,0xfc,0xeb,0x8e,0xf0,0xa4,0xfe,0xa9,0xf0,
        0xeb,0x8f,0xf0,0xa4,0xcf,0xc5,0xf0,0x2e,0xcd,0x39,0xfe,0xe4,0x3c,0xfc,0xea,0xa4,
        0x2d,0xce,0x35,0xf0,0xfd,0xe4,0x3c,0xfc,0x22,0x75,0xf0,0x08,0x75,0x82,0x00,0xef,
        0x2f,0xff,0xee,0x33,0xfe,0xcd,0x33,0xcd,0xcc,0x33,0xcc,0xc5,0x82,0x33,0xc5,0x82,
        0x9b,0xed,0x9a,0xec,0x99,0xe5,0x82,0x98,0x40,0x0c,0xf5,0x82,0xee,0x9b,0xfe,0xed,
        0x9a,0xfd,0xec,0x99,0xfc,0x0f,0xd5,0xf0,0xd6,0xe4,0xce,0xfb,0xe4,0xcd,0xfa,0xe4,
        0xcc,0xf9,0xa8,0x82,0x22,0xb8,0x00,0xc1,0xb9,0x00,0x59,0xba,0x00,0x2d,0xec,0x8b,
        0xf0,0x84,0xcf,0xce,0xcd,0xfc,0xe5,0xf0,0xcb,0xf9,0x78,0x18,0xef,0x2f,0xff,0xee,
        0x33,0xfe,0xed,0x33,0xfd,0xec,0x33,0xfc,0xeb,0x33,0xfb,0x10,0xd7,0x03,0x99,0x40,
        0x04,0xeb,0x99,0xfb,0x0f,0xd8,0xe5,0xe4,0xf9,0xfa,0x22,0x78,0x18,0xef,0x2f,0xff,
        0xee,0x33,0xfe,0xed,0x33,0xfd,0xec,0x33,0xfc,0xc9,0x33,0xc9,0x10,0xd7,0x05,0x9b,
        0xe9,0x9a,0x40,0x07,0xec,0x9b,0xfc,0xe9,0x9a,0xf9,0x0f,0xd8,0xe0,0xe4,0xc9,0xfa,
        0xe4,0xcc,0xfb,0x22,0x75,0xf0,0x10,0xef,0x2f,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,
        0xcc,0x33,0xcc,0xc8,0x33,0xc8,0x10,0xd7,0x07,0x9b,0xec,0x9a,0xe8,0x99,0x40,0x0a,
        0xed,0x9b,0xfd,0xec,0x9a,0xfc,0xe8,0x99,0xf8,0x0f,0xd5,0xf0,0xda,0xe4,0xcd,0xfb,
        0xe4,0xcc,0xfa,0xe4,0xc8,0xf9,0x22,0xeb,0x9f,0xf5,0xf0,0xea,0x9e,0x42,0xf0,0xe9,
        0x9d,0x42,0xf0,0xe8,0x9c,0x45,0xf0,0x22,0xe8,0x60,0x0f,0xec,0xc3,0x13,0xfc,0xed,
        0x13,0xfd,0xee,0x13,0xfe,0xef,0x13,0xff,0xd8,0xf1,0x22,0xe8,0x60,0x0f,0xef,0xc3,
        0x33,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xec,0x33,0xfc,0xd8,0xf1,0x22,0xe4,0x93,
        0xfc,0x74,0x01,0x93,0xfd,0x74,0x02,0x93,0xfe,0x74,0x03,0x93,0xff,0x22,0xec,0xf6,
        0x08,0xed,0xf6,0x08,0xee,0xf6,0x08,0xef,0xf6,0x22,0xd0,0x83,0xd0,0x82,0xe4,0x93,
        0xf6,0x08,0x74,0x01,0x93,0xf6,0x08,0x74,0x02,0x93,0xf6,0x08,0x74,0x03,0x93,0xf6,
        0x74,0x04,0x73,0xa4,0x25,0x82,0xf5,0x82,0xe5,0xf0,0x35,0x83,0xf5,0x83,0x22,0xd0,
        0x83,0xd0,0x82,0xf8,0xe4,0x93,0x70,0x12,0x74,0x01,0x93,0x70,0x0d,0xa3,0xa3,0x93,
        0xf8,0x74,0x01,0x93,0xf5,0x82,0x88,0x83,0xe4,0x73,0x74,0x02,0x93,0x68,0x60,0xef,
        0xa3,0xa3,0xa3,0x80,0xdf,0x85,0x3a,0x52,0x90,0x30,0x24,0xe0,0xf5,0x46,0xa3,0xe0,
        0xf5,0x47,0xa3,0xe0,0xf5,0x48,0xa3,0xe0,0xf5,0x49,0xa3,0xe0,0xf5,0x38,0xd2,0x09,
        0xe5,0x52,0x12,0x06,0xef,0x07,0x66,0x03,0x07,0x6c,0x07,0x07,0x7e,0x08,0x08,0x20,
        0x12,0x07,0xfc,0x80,0x07,0xfc,0x81,0x07,0x9c,0x8f,0x07,0xc3,0x90,0x07,0xc3,0x91,
        0x07,0xc3,0x92,0x07,0xc3,0x93,0x07,0xc3,0x94,0x07,0xdf,0x98,0x07,0xf4,0x9f,0x08,
        0x31,0xec,0x00,0x00,0x08,0x4f,0xe4,0xf5,0x20,0xd2,0x0d,0x22,0x85,0x4d,0x46,0x85,
        0x4e,0x47,0x85,0x4f,0x48,0x85,0x50,0x49,0x85,0x51,0x38,0x02,0x08,0x34,0x75,0x20,
        0x70,0xc2,0x0d,0xe4,0xf5,0x40,0x90,0x0e,0x33,0x12,0x08,0x50,0x90,0x0e,0x32,0xe4,
        0x12,0x08,0x50,0xe4,0xf5,0x09,0x12,0x0b,0xfd,0x02,0x08,0x34,0x12,0x09,0x76,0x50,
        0x03,0x02,0x08,0x34,0x75,0x20,0x16,0xe4,0xf5,0x4a,0xf5,0x4b,0xf5,0x38,0xe5,0x38,
        0x12,0x09,0x39,0x12,0x06,0xca,0x28,0x1e,0x28,0x1e,0x05,0x38,0xe5,0x38,0xb4,0x05,
        0xed,0x80,0x71,0xe5,0x20,0x64,0x16,0x70,0x6b,0xaf,0x49,0xae,0x48,0xad,0x47,0xac,
        0x46,0xe5,0x52,0x25,0xe0,0x25,0xe0,0x24,0xe2,0xf8,0x12,0x06,0xbe,0x80,0x55,0xe5,
        0x20,0x64,0x16,0x70,0x4f,0x85,0x46,0x3b,0x85,0x47,0x3c,0x85,0x48,0x3d,0x85,0x49,
        0x3e,0x85,0x38,0x3f,0xe5,0x20,0x64,0x16,0x70,0x3a,0x80,0x2c,0x12,0x09,0x76,0x40,
        0x33,0xe5,0x20,0x64,0x16,0x60,0x2d,0x75,0x20,0x16,0x12,0x0d,0xce,0xe5,0x52,0xb4,
        0x81,0x06,0x85,0x46,0x4a,0x85,0x47,0x4b,0xe4,0xf5,0x09,0x12,0x0b,0x70,0x80,0x08,
        0x12,0x09,0x76,0x40,0x0f,0x75,0x20,0x16,0x75,0x09,0x01,0x12,0x0b,0x70,0xd2,0x08,
        0x22,0x12,0x0e,0x86,0x90,0x30,0x24,0xe5,0x46,0xf0,0xa3,0xe5,0x47,0xf0,0xa3,0xe5,
        0x48,0xf0,0xa3,0xe5,0x49,0xf0,0xa3,0xe5,0x38,0xf0,0x90,0x30,0x23,0xe4,0xf0,0x22,
        0x93,0xf5,0x37,0x75,0x09,0x02,0x12,0x0b,0xfd,0x22,0xe5,0x09,0x25,0xe0,0x25,0xe0,
        0x24,0x24,0xf8,0xe6,0x75,0x83,0x00,0xf5,0x82,0xe5,0x09,0x25,0xe0,0x25,0xe0,0x24,
        0x25,0xf8,0xe6,0xfd,0x7c,0x00,0xaf,0x82,0x7e,0x00,0x12,0x04,0xf3,0x8e,0x83,0x8f,
        0x82,0xe5,0x82,0x45,0x83,0x22,0xf8,0xa6,0x07,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x25,
        0xf8,0xe6,0xff,0xeb,0x25,0xe0,0x25,0xe0,0x22,0x12,0x06,0x9b,0xe5,0x49,0x2f,0xf5,
        0x49,0xe5,0x48,0x3e,0xf5,0x48,0xe5,0x47,0x3d,0xf5,0x47,0xe5,0x46,0x3c,0xf5,0x46,
        0x22,0x74,0x4d,0x2b,0xf8,0xe6,0xd3,0x94,0x00,0x22,0xee,0x75,0xf0,0x0a,0xa4,0x24,
        0x6d,0xf8,0x22,0x8f,0x82,0x8e,0x83,0x75,0xf0,0x04,0xed,0x02,0x06,0xe3,0x74,0x4d,
        0x2f,0xf8,0xe6,0xd3,0x94,0x00,0x22,0xe9,0x24,0x01,0xfd,0xe4,0x33,0xfc,0xee,0xfb,
        0xc3,0xed,0x9b,0x74,0x80,0xf8,0x6c,0x98,0x22,0x12,0x05,0x5a,0x8f,0x0d,0x8e,0x0c,
        0x8d,0x0b,0x8c,0x0a,0x22,0xef,0x25,0xe0,0x28,0xf8,0xe6,0xfc,0x08,0xe6,0xfd,0x74,
        0x68,0x2f,0xf8,0x22,0x8f,0x0d,0x8e,0x0c,0x8d,0x0b,0x8c,0x0a,0x22,0xf8,0xe6,0xf5,
        0x09,0x08,0xe6,0xf5,0x0a,0x22,0xef,0x75,0xf0,0x0a,0xa4,0x24,0x6e,0xf8,0xeb,0x25,
        0xe0,0x28,0xf9,0x22,0xeb,0x25,0xe0,0x24,0xa0,0xf9,0x22,0xf8,0xe6,0xf9,0xd3,0x9d,
        0xec,0x64,0x80,0xf8,0x74,0x80,0x98,0x22,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x22,0xf8,
        0x22,0x78,0xdb,0xe6,0x25,0x36,0xf5,0x36,0x22,0x25,0x4c,0xf8,0xe6,0x24,0xd1,0xf8,
        0xe6,0x22,0xc3,0xe5,0x10,0x9f,0xf5,0x10,0xe5,0x0f,0x9e,0xf5,0x0f,0x22,0xc3,0xe5,
        0x12,0x9f,0xf5,0x12,0xe5,0x11,0x9e,0xf5,0x11,0x22,0x75,0xf0,0x08,0xa4,0x24,0x8b,
        0xf8,0xe6,0xfe,0x08,0xe6,0x22,0xe5,0x20,0x54,0x7f,0xc3,0x94,0x10,0x22,0x78,0xdb,
        0xa6,0x07,0xc3,0xe5,0x36,0x96,0xf5,0x36,0x22,0xe0,0xa3,0xe0,0x75,0xf0,0x02,0xa4,
        0xff,0xae,0xf0,0x22,0x25,0x0e,0xf8,0xe6,0xff,0xe4,0xfc,0xfd,0xfe,0x22,0x75,0xa8,
        0x07,0x75,0xb8,0x04,0x75,0x09,0xff,0x75,0x0a,0x0e,0x75,0x0b,0x02,0x75,0x0c,0x09,
        0x12,0x0f,0x68,0xd2,0xaf,0x75,0x09,0xff,0x75,0x0a,0x0e,0x75,0x0b,0x26,0x75,0x0c,
        0x03,0x12,0x0f,0x68,0x12,0x0d,0xce,0xe4,0xf5,0x09,0x12,0x0b,0x70,0x75,0x09,0x01,
        0x12,0x0b,0x70,0x12,0x00,0x16,0xc2,0x08,0xd2,0x09,0x75,0x20,0x70,0x30,0x0e,0x05,
        0xc2,0x0e,0x12,0x07,0x15,0x30,0x08,0x15,0xe5,0x20,0xb4,0x16,0x0e,0x12,0x0a,0xb0,
        0x12,0x00,0x16,0x75,0x20,0x70,0x90,0x30,0x23,0xe4,0xf0,0xc2,0x08,0x20,0x0c,0x03,
        0x02,0x0a,0xa0,0xc2,0x0d,0x30,0x07,0x05,0xc2,0x07,0x02,0x0a,0x9c,0xe5,0x20,0x70,
        0x05,0x12,0x0f,0xa8,0x80,0x71,0x74,0x05,0xd3,0x95,0x20,0x40,0x02,0x80,0x17,0xe5,
        0x20,0xb4,0x05,0x0b,0x14,0xf5,0x09,0x12,0x0d,0x69,0x12,0x02,0xce,0x80,0x58,0x74,
        0x0a,0xd3,0x95,0x20,0x40,0x0b,0x12,0x0f,0xf4,0x12,0x0a,0xa9,0xe5,0x20,0x14,0x80,
        0x2e,0xe5,0x20,0xb4,0x0a,0x15,0x14,0xf5,0x09,0x12,0x0d,0x69,0x12,0x0f,0x20,0x12,
        0x0a,0xa9,0x90,0x0e,0x34,0xe4,0x93,0xf5,0x37,0x80,0x41,0x74,0x0d,0xd3,0x95,0x20,
        0x40,0x16,0x12,0x0f,0xe2,0x75,0x09,0x02,0x12,0x0b,0xfd,0xe5,0x20,0x24,0xf5,0xf5,
        0x09,0x12,0x0d,0x69,0x05,0x20,0x80,0x24,0xe5,0x20,0xb4,0x0d,0x12,0x24,0xf5,0xf5,
        0x09,0x12,0x0d,0x69,0x12,0x0c,0x80,0x75,0x09,0x02,0x12,0x0b,0xfd,0x80,0x0d,0xe5,
        0x20,0xb4,0x0e,0x08,0x12,0x0d,0xf9,0x90,0x30,0x23,0xe4,0xf0,0xc2,0x0c,0xd2,0x0d,
        0x90,0x30,0x29,0xe5,0x20,0xf0,0x02,0x09,0xdd,0x75,0x09,0x02,0x12,0x0b,0xfd,0x22,
        0xe4,0x75,0x0d,0xff,0x75,0x0c,0xff,0xf5,0x0b,0xf5,0x0a,0xf5,0x09,0x74,0x3b,0x25,
        0x09,0xf8,0xe6,0x60,0x16,0x12,0x08,0x5a,0x60,0x11,0xc3,0xe5,0x82,0x95,0x0d,0xe5,
        0x83,0x95,0x0c,0x50,0x06,0x85,0x83,0x0c,0x85,0x82,0x0d,0x05,0x09,0xe5,0x09,0xb4,
        0x05,0xdb,0xe4,0x7f,0x01,0xfe,0xfd,0xfc,0xab,0x0d,0xaa,0x0c,0xa9,0x0b,0xa8,0x0a,
        0xc3,0x12,0x06,0x77,0x50,0x0a,0xe4,0x75,0x0d,0x01,0xf5,0x0c,0xf5,0x0b,0xf5,0x0a,
        0xaf,0x0d,0xae,0x0c,0xad,0x0b,0xac,0x0a,0xe4,0x7b,0x80,0xfa,0xf9,0xf8,0x12,0x05,
        0x5a,0x8f,0x0d,0x8e,0x0c,0x8d,0x0b,0x8c,0x0a,0xe4,0xf5,0x09,0x74,0x3b,0x25,0x09,
        0xf8,0xe6,0x70,0x02,0x80,0x2f,0x12,0x08,0x5a,0x70,0x09,0x74,0x41,0x25,0x09,0xf8,
        0x76,0x80,0x80,0x33,0xab,0x82,0xaa,0x83,0xe4,0xf9,0xf8,0xaf,0x0d,0xae,0x0c,0xad,
        0x0b,0xac,0x0a,0x12,0x05,0xe5,0x8e,0x83,0x8f,0x82,0xc3,0xe5,0x82,0x94,0x01,0xe5,
        0x83,0x94,0x00,0x50,0x09,0x74,0x41,0x25,0x09,0xf8,0x76,0x01,0x80,0x09,0xaf,0x82,
        0x74,0x41,0x25,0x09,0xf8,0xa6,0x07,0x05,0x09,0xe5,0x09,0x64,0x05,0x70,0xad,0x22,
        0xe4,0xfb,0xe5,0x09,0x70,0x2d,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x65,0xf5,0x82,0xe4,
        0x34,0x0e,0xf5,0x83,0x12,0x06,0xae,0x12,0x09,0x38,0x12,0x06,0xbe,0x12,0x09,0x38,
        0xe5,0x4a,0x26,0xf6,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x23,0xf8,0xe5,0x4b,0x26,0xf6,
        0x02,0x0b,0xf3,0xe5,0x09,0x64,0x01,0x70,0x4a,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x24,
        0x12,0x08,0x90,0x24,0x22,0xf8,0xe6,0xc3,0x9f,0x12,0x08,0x92,0x24,0x6d,0x12,0x08,
        0x86,0x24,0x23,0xf8,0xe6,0xc3,0x9f,0x12,0x08,0x92,0x24,0x6e,0xf8,0xa6,0x07,0xeb,
        0x25,0xe0,0x25,0xe0,0x24,0x24,0x12,0x08,0x90,0x24,0x22,0xf8,0xe6,0x2f,0x12,0x08,
        0x92,0x24,0x6f,0x12,0x08,0x86,0x24,0x23,0xf8,0xe6,0x2f,0x12,0x08,0x92,0x24,0x70,
        0xf8,0xa6,0x07,0x0b,0xeb,0x64,0x05,0x60,0x03,0x02,0x0b,0x72,0x22,0xe5,0x09,0x60,
        0x68,0xd3,0x94,0x01,0x40,0x08,0xe5,0x36,0x90,0x0e,0x3c,0x93,0xf5,0x40,0x90,0x0e,
        0x38,0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xc3,0x90,0x0e,0x36,0x74,0x01,0x93,0x9f,
        0xff,0xe4,0x93,0x9e,0xfe,0xe4,0x8f,0x0d,0x8e,0x0c,0xf5,0x0b,0xf5,0x0a,0xab,0x0d,
        0xaa,0x0c,0xa9,0x0b,0xa8,0x0a,0xaf,0x40,0xfc,0xfd,0xfe,0x12,0x05,0x5a,0x12,0x09,
        0x04,0xe4,0x7b,0xff,0xfa,0xf9,0xf8,0x12,0x05,0xe5,0x12,0x09,0x04,0x78,0x04,0x12,
        0x06,0x9b,0x12,0x09,0x04,0xe5,0x0d,0x45,0x37,0xf5,0x0d,0xe5,0x0c,0xf5,0x0c,0xe5,
        0x0b,0xf5,0x0b,0xe5,0x0a,0xf5,0x0a,0x80,0x0c,0xe4,0xf5,0x0d,0x75,0x0c,0x80,0xf5,
        0x0b,0xf5,0x0a,0xf5,0x36,0x90,0x36,0x02,0xe5,0x0d,0xf0,0xa3,0xe5,0x0c,0xf0,0x22,
        0xe4,0xf5,0x0d,0xf5,0x0e,0x75,0x0f,0x03,0x12,0x0e,0xd8,0xe4,0xf5,0x0c,0xf5,0x0b,
        0xff,0x12,0x08,0xce,0x50,0x10,0xef,0x65,0x4c,0x60,0x0b,0x05,0x0c,0x74,0x68,0x2f,
        0xf8,0xe6,0x25,0x0b,0xf5,0x0b,0x0f,0xbf,0x05,0xe7,0xe5,0x0c,0xc3,0x13,0x25,0x0b,
        0xf5,0x0b,0x85,0x0c,0xf0,0x84,0xf5,0x0b,0xfe,0x24,0x01,0xfd,0xe4,0x33,0xfc,0x74,
        0x68,0x25,0x4c,0x12,0x09,0x2b,0x50,0x05,0x12,0x08,0xd7,0x50,0x02,0xae,0x01,0xe4,
        0xff,0x12,0x08,0xce,0x50,0x1a,0xee,0x24,0x01,0xfd,0xe4,0x33,0xfc,0x74,0x68,0x2f,
        0x12,0x09,0x2b,0x50,0x05,0x12,0x08,0xd7,0x50,0x06,0x74,0x4d,0x2f,0xf8,0x76,0x05,
        0x0f,0xbf,0x05,0xdd,0x74,0xd1,0x2e,0xf8,0xe6,0xf5,0x36,0x75,0x20,0x8e,0x22,0xc0,
        0xe0,0xc0,0x83,0xc0,0x82,0x90,0x3f,0x0c,0xe0,0xf5,0x08,0xe5,0x08,0x30,0xe3,0x37,
        0x30,0x0d,0x34,0x90,0x60,0x19,0xe0,0xf5,0x54,0xa3,0xe0,0xf5,0x55,0x90,0x60,0x21,
        0xe0,0xf5,0x56,0xa3,0xe0,0xf5,0x57,0x90,0x60,0x29,0xe0,0xf5,0x58,0xa3,0xe0,0xf5,
        0x59,0x90,0x60,0x31,0xe0,0xf5,0x5a,0xa3,0xe0,0xf5,0x5b,0x90,0x60,0x39,0xe0,0xf5,
        0x5c,0xa3,0xe0,0xf5,0x5d,0xd2,0x0c,0xe5,0x08,0x30,0xe1,0x10,0x30,0x09,0x0d,0x90,
        0x30,0x22,0xe0,0x75,0x39,0x00,0xf5,0x3a,0xe4,0xf0,0xd2,0x0e,0x90,0x3f,0x0c,0xe5,
        0x08,0xf0,0xd0,0x82,0xd0,0x83,0xd0,0xe0,0x32,0xe4,0xf5,0x0e,0xe5,0x0e,0x25,0xe0,
        0x24,0x54,0xf8,0xe6,0xfe,0x08,0xe6,0xff,0xe4,0x8f,0x0d,0x8e,0x0c,0xf5,0x0b,0xf5,
        0x0a,0xab,0x0d,0xaa,0x0c,0xa9,0x0b,0xa8,0x0a,0xc0,0x00,0x74,0x3b,0x12,0x09,0x94,
        0xd0,0x00,0x12,0x08,0xe9,0xab,0x0d,0xaa,0x0c,0xa9,0x0b,0xa8,0x0a,0xc0,0x00,0x74,
        0x41,0x12,0x09,0x94,0xd0,0x00,0x12,0x08,0xe9,0xe4,0x7b,0x80,0xfa,0xf9,0xf8,0x12,
        0x05,0xe5,0x12,0x08,0xec,0xe5,0x09,0x12,0x08,0xbb,0xe5,0x0e,0x25,0xe0,0x28,0xf8,
        0xa6,0x0c,0x08,0xa6,0x0d,0x05,0x0e,0xe5,0x0e,0x64,0x05,0x70,0x9f,0x22,0x90,0x0e,
        0x63,0xe4,0x93,0xf5,0x4a,0xa3,0xe4,0x93,0xf5,0x4b,0xe4,0xff,0xef,0x90,0x0e,0x79,
        0x93,0xfe,0x74,0x3b,0x2f,0xf8,0xa6,0x06,0xef,0x90,0x0e,0x7e,0x93,0xfe,0x74,0x41,
        0x2f,0xf8,0xa6,0x06,0x0f,0xbf,0x05,0xe4,0x22,0x75,0x20,0x10,0x22,0x00,0x00,0x00,
        0x56,0x40,0x30,0x04,0x20,0xdf,0x30,0x05,0x40,0xbf,0x50,0x25,0x04,0xfb,0x60,0x00,
        0x11,0x00,0x3f,0x05,0x30,0x00,0x3f,0x06,0x22,0x00,0x3f,0x01,0x29,0x00,0x3f,0x02,
        0x00,0x00,0x3f,0x0b,0x0f,0xf0,0x30,0x01,0x40,0xbf,0x30,0x01,0x00,0xbf,0x30,0x29,
        0x7e,0x00,0x00,0x02,0x04,0x06,0x03,0x66,0x00,0x00,0x00,0x24,0x1e,0x23,0x28,0x2d,
        0x32,0x37,0x3c,0x41,0x46,0x4b,0x50,0x55,0x5a,0x5f,0x64,0x69,0x6e,0x73,0x78,0x7e,
        0x84,0x8a,0x90,0x96,0x9c,0xa3,0xaa,0xb1,0xb8,0xbf,0xc6,0xcd,0xd5,0xde,0xe8,0xf3,
        0xff,0x50,0x3c,0x20,0x18,0x08,0x09,0x08,0x03,0x04,0x06,0x04,0x06,0x08,0x06,0x08,
        0x06,0x0c,0x06,0x04,0x06,0x08,0x03,0x08,0x03,0x04,0x04,0x08,0x04,0x04,0x80,0x80,
        0x80,0x80,0x80,0x0a,0x0c,0x10,0xe5,0x49,0x24,0xf2,0xf5,0x0c,0xe5,0x48,0x34,0x43,
        0xf5,0x0b,0xe5,0x47,0x34,0xa2,0xf5,0x0a,0xe5,0x46,0x34,0x28,0xf5,0x09,0x85,0x0c,
        0x46,0xe5,0x0c,0x54,0xa0,0xff,0xe5,0x0b,0xfe,0xe4,0xfd,0xfc,0x78,0x07,0x12,0x06,
        0x88,0x78,0x10,0x12,0x08,0x99,0xe4,0xff,0xfe,0xe5,0x0a,0xfd,0xe4,0xfc,0x78,0x0e,
        0x12,0x06,0x88,0x12,0x08,0x9c,0xe4,0xff,0xfe,0xfd,0xe5,0x09,0xfc,0x78,0x18,0x12,
        0x06,0x88,0x78,0x08,0x12,0x08,0x99,0x22,0xe4,0xff,0x74,0x68,0x2f,0xf8,0xe4,0xf6,
        0x12,0x08,0xce,0x50,0x34,0xe5,0x0d,0x12,0x08,0xbb,0x12,0x08,0xf5,0xe4,0xf6,0xae,
        0x0d,0xee,0xc3,0x95,0x0f,0xe4,0x95,0x0e,0x50,0x1f,0x12,0x08,0xba,0xef,0x25,0xe0,
        0x28,0xf8,0xe6,0xfa,0x08,0xe6,0xfb,0xd3,0xed,0x9b,0xec,0x9a,0x50,0x08,0x12,0x08,
        0xba,0x12,0x08,0xf5,0xa6,0x06,0x0e,0x80,0xd8,0x0f,0xef,0x64,0x05,0x70,0xbb,0x22,
        0x75,0x0d,0x05,0x75,0x0e,0x00,0x75,0x0f,0x0a,0x12,0x0e,0xd8,0xe4,0xff,0x12,0x08,
        0xce,0x50,0x13,0x74,0x68,0x25,0x4c,0xf9,0x74,0x68,0x2f,0xf8,0xe6,0x67,0x60,0x06,
        0x74,0x4d,0x2f,0xf8,0x76,0x04,0x0f,0xbf,0x05,0xe4,0x74,0x68,0x12,0x09,0x49,0xf5,
        0x36,0x30,0x0b,0x04,0x7f,0x01,0x80,0x02,0x7f,0xff,0x12,0x09,0x7e,0x74,0xc7,0x25,
        0x20,0xf8,0xa6,0x36,0x75,0x20,0x8b,0x22,0xae,0x0a,0xaf,0x0b,0xe4,0xfd,0xed,0xc3,
        0x95,0x0c,0x50,0x33,0x12,0x08,0xc3,0xe4,0x93,0xf5,0x0d,0x74,0x01,0x93,0xf5,0x0e,
        0x45,0x0d,0x60,0x23,0x85,0x0e,0x82,0x85,0x0d,0x83,0xe0,0xfc,0x12,0x08,0xc3,0x74,
        0x03,0x93,0x52,0x04,0x12,0x08,0xc3,0x74,0x02,0x93,0x42,0x04,0x85,0x0e,0x82,0x85,
        0x0d,0x83,0xec,0xf0,0x0d,0x80,0xc7,0x22,0xe5,0x40,0xc3,0x94,0x69,0x50,0x02,0x80,
        0x01,0xc3,0x92,0x0b,0x90,0x0e,0x33,0xe4,0x93,0xf5,0x37,0x30,0x0b,0x04,0x7f,0x06,
        0x80,0x02,0x7f,0xfa,0x78,0xdb,0xa6,0x07,0x30,0x0b,0x05,0x90,0x0e,0x3a,0x80,0x03,
        0x90,0x0e,0x3b,0xe4,0x93,0xff,0x8f,0x36,0x12,0x09,0x41,0x78,0xd1,0xf6,0x75,0x20,
        0x81,0x22,0x90,0x0e,0x35,0xe4,0x93,0xf5,0x37,0x12,0x09,0x41,0x74,0xc7,0x25,0x20,
        0xf8,0xa6,0x36,0x22,0x12,0x09,0x41,0x74,0xd1,0x25,0x20,0xf8,0xa6,0x36,0x22
    };
#else
    static const kal_uint8 AfFw1p01[] =
    {
        0x02,0x00,0x06,0x02,0x0c,0xff,0x78,0x7f,0xe4,0xf6,0xd8,0xfd,0x75,0x81,0xe4,
        0x02,0x09,0x9e,0x32,0x02,0x00,0x12,0x90,0x38,0x04,0xe0,0xfe,0xa3,0xe0,0xfd,
        0xee,0xf5,0x0f,0xed,0xf5,0x10,0x90,0x38,0x00,0xe0,0xfe,0xa3,0xe0,0xfd,0xed,
        0xff,0x12,0x09,0x52,0x90,0x38,0x10,0x12,0x09,0x89,0x12,0x09,0x52,0x90,0x38,
        0x06,0xe0,0xfe,0xa3,0xe0,0xfd,0xee,0xf5,0x11,0xed,0xf5,0x12,0x90,0x38,0x02,
        0xe0,0xfe,0xa3,0xe0,0xfd,0xed,0xff,0x12,0x09,0x5e,0x90,0x38,0x12,0x12,0x09,
        0x89,0x12,0x09,0x5e,0xa3,0xe0,0xb4,0x31,0x0b,0xe5,0x0f,0xc3,0x13,0xf5,0x0f,
        0xe5,0x10,0x13,0xf5,0x10,0x90,0x38,0x14,0xe0,0xb4,0x71,0x11,0xe5,0x10,0xae,
        0x0f,0x78,0x02,0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,0xf5,0x10,0x8e,0x0f,0x90,
        0x38,0x15,0xe0,0xb4,0x31,0x0b,0xe5,0x11,0xc3,0x13,0xf5,0x11,0xe5,0x12,0x13,
        0xf5,0x12,0x90,0x38,0x15,0xe0,0xb4,0x71,0x11,0xe5,0x12,0xae,0x11,0x78,0x02,
        0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,0xf5,0x12,0x8e,0x11,0xe5,0x0f,0xc4,0xf8,
        0x54,0xf0,0xc8,0x68,0xf5,0x0f,0xe5,0x10,0xc4,0x54,0x0f,0x48,0xf5,0x10,0xe5,
        0x11,0xc4,0xf8,0x54,0xf0,0xc8,0x68,0xf5,0x11,0xe5,0x12,0xc4,0x54,0x0f,0x48,
        0xf5,0x12,0xe4,0xfa,0xea,0x70,0x04,0x7f,0x04,0x80,0x02,0x7f,0x03,0x8f,0x0d,
        0xe5,0x0d,0x25,0xe0,0xf5,0x0e,0xea,0x70,0x06,0xae,0x0f,0xaf,0x10,0x80,0x04,
        0xae,0x11,0xaf,0x12,0x8e,0x13,0x8f,0x14,0xe4,0xfb,0xc3,0xe5,0x14,0x95,0x0e,
        0xe5,0x13,0x94,0x00,0x50,0x0e,0xe4,0xf5,0x09,0xf5,0x0a,0x85,0x13,0x0b,0x85,
        0x14,0x0c,0x02,0x02,0x00,0xea,0x70,0x09,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x6d,
        0x80,0x07,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x6e,0xf8,0xe6,0x75,0x09,0x00,0xf5,
        0x0a,0xae,0x09,0xaf,0x0a,0xac,0x13,0xad,0x14,0x12,0x04,0xf3,0x8e,0x09,0x8f,
        0x0a,0xea,0x70,0x09,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x6f,0x80,0x07,0xeb,0x25,
        0xe0,0x25,0xe0,0x24,0x70,0xf8,0xe6,0x75,0x0b,0x00,0xf5,0x0c,0xae,0x0b,0xaf,
        0x0c,0xac,0x13,0xad,0x14,0x12,0x04,0xf3,0x8e,0x0b,0x8f,0x0c,0xea,0xae,0x09,
        0xaf,0x0a,0x60,0x05,0x90,0x0e,0x62,0x80,0x03,0x90,0x0e,0x61,0xe4,0x93,0xfd,
        0x7c,0x00,0x12,0x05,0x05,0x8e,0x09,0x8f,0x0a,0xae,0x0b,0xaf,0x0c,0xe4,0x93,
        0xfd,0x7c,0x00,0x12,0x05,0x05,0x8e,0x0b,0x8f,0x0c,0xc3,0xe5,0x0c,0x95,0x0a,
        0xff,0xe5,0x0b,0x95,0x09,0xfe,0xc3,0xef,0x95,0x0e,0xee,0x94,0x00,0x50,0x5c,
        0xe5,0x0c,0x25,0x0a,0xff,0xe5,0x0b,0x35,0x09,0xc3,0x13,0xfe,0xef,0x13,0xff,
        0xc3,0x95,0x0d,0xee,0x94,0x00,0x50,0x0c,0xe4,0xf5,0x09,0xf5,0x0a,0xf5,0x0b,
        0x85,0x0e,0x0c,0x80,0x39,0xe5,0x0d,0x2f,0xfd,0xe4,0x3e,0xfc,0xd3,0xed,0x95,
        0x14,0xec,0x95,0x13,0x40,0x14,0x85,0x13,0x0b,0x85,0x14,0x0c,0xe5,0x14,0x95,
        0x0e,0xf5,0x0a,0xe5,0x13,0x94,0x00,0xf5,0x09,0x80,0x15,0xad,0x0d,0x7c,0x00,
        0xc3,0xef,0x9d,0xf5,0x0a,0xee,0x9c,0xf5,0x09,0xed,0x2f,0xf5,0x0c,0xec,0x3e,
        0xf5,0x0b,0xeb,0x75,0xf0,0x08,0xa4,0x24,0x85,0xf8,0xea,0x25,0xe0,0x28,0xf8,
        0xa6,0x09,0x08,0xa6,0x0a,0xeb,0x75,0xf0,0x08,0xa4,0x24,0x89,0xf8,0xea,0x25,
        0xe0,0x28,0xf8,0xa6,0x0b,0x08,0xa6,0x0c,0x0b,0xeb,0x64,0x05,0x60,0x03,0x02,
        0x00,0xfa,0x0a,0xea,0x64,0x02,0x60,0x03,0x02,0x00,0xd6,0xe4,0xfa,0x7b,0x01,
        0xeb,0x75,0xf0,0x08,0xa4,0x24,0x8c,0xf9,0xea,0x12,0x09,0x6a,0xc3,0x97,0xee,
        0x19,0x97,0x50,0x04,0xaf,0x03,0x80,0x02,0xaf,0x02,0xaa,0x07,0x0b,0xbb,0x05,
        0xe1,0xea,0x60,0x0b,0x12,0x09,0x6a,0xff,0x78,0x8b,0xa6,0x06,0x08,0xa6,0x07,
        0x78,0x86,0xe6,0x90,0x60,0x01,0xf0,0x78,0x88,0xe6,0xa3,0xf0,0x78,0x8a,0xe6,
        0xa3,0xf0,0x78,0x8c,0xe6,0xa3,0xf0,0x78,0x8e,0xe6,0xa3,0xf0,0x78,0x90,0xe6,
        0xa3,0xf0,0x78,0x92,0xe6,0xa3,0xf0,0x78,0x94,0xe6,0xa3,0xf0,0x78,0x96,0xe6,
        0xa3,0xf0,0x78,0x98,0xe6,0xa3,0xf0,0x78,0x9a,0xe6,0xa3,0xf0,0x78,0x9c,0xe6,
        0xa3,0xf0,0x78,0x9e,0xe6,0xa3,0xf0,0x78,0xa0,0xe6,0xa3,0xf0,0x78,0xa2,0xe6,
        0xa3,0xf0,0x78,0xa4,0xe6,0xa3,0xf0,0x78,0xa6,0xe6,0xa3,0xf0,0x78,0xa8,0xe6,
        0xa3,0xf0,0x78,0xaa,0xe6,0xa3,0xf0,0x78,0xac,0xe6,0xa3,0xf0,0x22,0xe4,0xf5,
        0x0d,0x75,0x0e,0xff,0xfb,0x74,0x3b,0x12,0x08,0xb3,0x40,0x28,0x74,0x4d,0x2b,
        0xf8,0xe4,0xf6,0x74,0x3b,0x2b,0xf8,0xe6,0xff,0xe5,0x0e,0xd3,0x9f,0x40,0x02,
        0x80,0x02,0xaf,0x0e,0x8f,0x0e,0xe6,0xff,0xe5,0x0d,0xc3,0x9f,0x50,0x02,0x80,
        0x02,0xaf,0x0d,0x8f,0x0d,0x80,0x06,0x74,0x4d,0x2b,0xf8,0x76,0x01,0x0b,0xbb,
        0x05,0xc7,0xe4,0xfb,0x74,0xe0,0x2b,0xf8,0xe4,0xf6,0x12,0x08,0xb1,0x40,0x03,
        0x02,0x03,0xb0,0xeb,0x25,0xe0,0x24,0x6d,0x12,0x09,0x0d,0x85,0x09,0x0b,0xf5,
        0x0c,0x74,0xe0,0x2b,0xf8,0xe4,0xf6,0x7f,0x01,0x12,0x09,0x16,0xc3,0xe5,0x0a,
        0x97,0xe5,0x09,0x19,0x97,0x50,0x11,0xef,0x12,0x08,0xbb,0xeb,0x25,0xe0,0x28,
        0x12,0x09,0x0d,0x74,0xe0,0x2b,0xf8,0xa6,0x07,0x12,0x09,0x16,0xd3,0xe5,0x0c,
        0x97,0xe5,0x0b,0x19,0x97,0x40,0x10,0xef,0x12,0x08,0xbb,0xeb,0x25,0xe0,0x28,
        0xf8,0xe6,0xf5,0x0b,0x08,0xe6,0xf5,0x0c,0x0f,0xbf,0x05,0xc1,0xeb,0x25,0xe0,
        0x24,0x9f,0xf8,0xa6,0x09,0x08,0xa6,0x0a,0xae,0x0b,0xaf,0x0c,0x90,0x0e,0x83,
        0xe4,0x93,0xfd,0x7c,0x00,0x12,0x04,0xf3,0x8e,0x0b,0x8f,0x0c,0xae,0x09,0xaf,
        0x0a,0xa3,0xe4,0x93,0xfd,0x12,0x04,0xf3,0x8e,0x09,0x8f,0x0a,0xd3,0xe5,0x0c,
        0x95,0x0a,0xe5,0x0b,0x95,0x09,0x40,0x06,0x74,0x4d,0x2b,0xf8,0x76,0x02,0x0b,
        0xeb,0x64,0x05,0x60,0x03,0x02,0x03,0x10,0xe4,0xf5,0x09,0xf5,0x0a,0xff,0xfb,
        0x12,0x08,0xb1,0x50,0x35,0xef,0x70,0x09,0x74,0xe0,0x2b,0x12,0x09,0x4b,0xff,
        0x80,0x29,0x74,0xe0,0x2b,0xf8,0xe6,0xfe,0x24,0xd1,0xf8,0xe6,0xd3,0x9f,0x40,
        0x06,0x74,0xd1,0x2e,0xf8,0xe6,0xff,0x12,0x09,0x24,0xd3,0xe7,0x95,0x0a,0x19,
        0xe7,0x95,0x09,0x40,0x08,0xeb,0x25,0xe0,0x24,0x9f,0x12,0x09,0x0d,0x0b,0xbb,
        0x05,0xc2,0xef,0x70,0x06,0xf5,0x36,0x75,0x20,0x8e,0x22,0x85,0x0d,0x0c,0x85,
        0x0e,0x0b,0xe4,0xfb,0x12,0x08,0xb1,0x50,0x2c,0x74,0x3b,0x2b,0xf8,0xe6,0xff,
        0xe5,0x0c,0xd3,0x9f,0x40,0x08,0xe5,0x0e,0xd3,0x9f,0x50,0x02,0x80,0x02,0xaf,
        0x0c,0x8f,0x0c,0xe6,0xff,0xe5,0x0b,0xc3,0x9f,0x50,0x08,0xe5,0x0d,0xc3,0x9f,
        0x40,0x02,0x80,0x02,0xaf,0x0b,0x8f,0x0b,0x0b,0xbb,0x05,0xcb,0xe5,0x0b,0x65,
        0x0e,0x60,0x4e,0xe4,0xfb,0x12,0x08,0xb1,0x50,0x18,0x74,0x3b,0x2b,0xf8,0xe6,
        0xb5,0x0b,0x10,0x12,0x09,0x24,0xe7,0xb5,0x0a,0x09,0x19,0xe7,0xb5,0x09,0x04,
        0x8b,0x4c,0x80,0x4a,0x0b,0xbb,0x05,0xdf,0xe4,0xfb,0x12,0x08,0xb1,0x50,0x18,
        0x74,0x3b,0x2b,0xf8,0xe6,0xb5,0x0b,0x10,0x12,0x09,0x24,0xe7,0xb5,0x0a,0x09,
        0x19,0xe7,0xb5,0x09,0x04,0x8b,0x4c,0x80,0x27,0x0b,0xbb,0x05,0xdf,0xe5,0x0b,
        0x14,0xf5,0x0d,0x02,0x04,0x07,0xe4,0xfb,0x12,0x08,0xb1,0x50,0x10,0x12,0x09,
        0x24,0xe7,0xb5,0x0a,0x09,0x19,0xe7,0xb5,0x09,0x04,0x8b,0x4c,0x80,0x04,0x0b,
        0xbb,0x05,0xe7,0xe4,0xfb,0x12,0x08,0xb1,0x50,0x13,0x74,0xe0,0x25,0x4c,0xf9,
        0x74,0xe0,0x2b,0xf8,0xe6,0x67,0x60,0x06,0x74,0x4d,0x2b,0xf8,0x76,0x03,0x0b,
        0xbb,0x05,0xe4,0x74,0xe0,0x12,0x09,0x49,0xf5,0x36,0x30,0x0b,0x04,0x7f,0xfe,
        0x80,0x02,0x7f,0x02,0x12,0x09,0x7e,0xc3,0x96,0xf5,0x36,0x74,0xd1,0x25,0x20,
        0xf8,0xa6,0x36,0x75,0x20,0x86,0x22,0xef,0x8d,0xf0,0xa4,0xa8,0xf0,0xcf,0x8c,
        0xf0,0xa4,0x28,0xce,0x8d,0xf0,0xa4,0x2e,0xfe,0x22,0xbc,0x00,0x0b,0xbe,0x00,
        0x29,0xef,0x8d,0xf0,0x84,0xff,0xad,0xf0,0x22,0xe4,0xcc,0xf8,0x75,0xf0,0x08,
        0xef,0x2f,0xff,0xee,0x33,0xfe,0xec,0x33,0xfc,0xee,0x9d,0xec,0x98,0x40,0x05,
        0xfc,0xee,0x9d,0xfe,0x0f,0xd5,0xf0,0xe9,0xe4,0xce,0xfd,0x22,0xed,0xf8,0xf5,
        0xf0,0xee,0x84,0x20,0xd2,0x1c,0xfe,0xad,0xf0,0x75,0xf0,0x08,0xef,0x2f,0xff,
        0xed,0x33,0xfd,0x40,0x07,0x98,0x50,0x06,0xd5,0xf0,0xf2,0x22,0xc3,0x98,0xfd,
        0x0f,0xd5,0xf0,0xea,0x22,0xe8,0x8f,0xf0,0xa4,0xcc,0x8b,0xf0,0xa4,0x2c,0xfc,
        0xe9,0x8e,0xf0,0xa4,0x2c,0xfc,0x8a,0xf0,0xed,0xa4,0x2c,0xfc,0xea,0x8e,0xf0,
        0xa4,0xcd,0xa8,0xf0,0x8b,0xf0,0xa4,0x2d,0xcc,0x38,0x25,0xf0,0xfd,0xe9,0x8f,
        0xf0,0xa4,0x2c,0xcd,0x35,0xf0,0xfc,0xeb,0x8e,0xf0,0xa4,0xfe,0xa9,0xf0,0xeb,
        0x8f,0xf0,0xa4,0xcf,0xc5,0xf0,0x2e,0xcd,0x39,0xfe,0xe4,0x3c,0xfc,0xea,0xa4,
        0x2d,0xce,0x35,0xf0,0xfd,0xe4,0x3c,0xfc,0x22,0x75,0xf0,0x08,0x75,0x82,0x00,
        0xef,0x2f,0xff,0xee,0x33,0xfe,0xcd,0x33,0xcd,0xcc,0x33,0xcc,0xc5,0x82,0x33,
        0xc5,0x82,0x9b,0xed,0x9a,0xec,0x99,0xe5,0x82,0x98,0x40,0x0c,0xf5,0x82,0xee,
        0x9b,0xfe,0xed,0x9a,0xfd,0xec,0x99,0xfc,0x0f,0xd5,0xf0,0xd6,0xe4,0xce,0xfb,
        0xe4,0xcd,0xfa,0xe4,0xcc,0xf9,0xa8,0x82,0x22,0xb8,0x00,0xc1,0xb9,0x00,0x59,
        0xba,0x00,0x2d,0xec,0x8b,0xf0,0x84,0xcf,0xce,0xcd,0xfc,0xe5,0xf0,0xcb,0xf9,
        0x78,0x18,0xef,0x2f,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xec,0x33,0xfc,0xeb,
        0x33,0xfb,0x10,0xd7,0x03,0x99,0x40,0x04,0xeb,0x99,0xfb,0x0f,0xd8,0xe5,0xe4,
        0xf9,0xfa,0x22,0x78,0x18,0xef,0x2f,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xec,
        0x33,0xfc,0xc9,0x33,0xc9,0x10,0xd7,0x05,0x9b,0xe9,0x9a,0x40,0x07,0xec,0x9b,
        0xfc,0xe9,0x9a,0xf9,0x0f,0xd8,0xe0,0xe4,0xc9,0xfa,0xe4,0xcc,0xfb,0x22,0x75,
        0xf0,0x10,0xef,0x2f,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xcc,0x33,0xcc,0xc8,
        0x33,0xc8,0x10,0xd7,0x07,0x9b,0xec,0x9a,0xe8,0x99,0x40,0x0a,0xed,0x9b,0xfd,
        0xec,0x9a,0xfc,0xe8,0x99,0xf8,0x0f,0xd5,0xf0,0xda,0xe4,0xcd,0xfb,0xe4,0xcc,
        0xfa,0xe4,0xc8,0xf9,0x22,0xeb,0x9f,0xf5,0xf0,0xea,0x9e,0x42,0xf0,0xe9,0x9d,
        0x42,0xf0,0xe8,0x9c,0x45,0xf0,0x22,0xe8,0x60,0x0f,0xec,0xc3,0x13,0xfc,0xed,
        0x13,0xfd,0xee,0x13,0xfe,0xef,0x13,0xff,0xd8,0xf1,0x22,0xe8,0x60,0x0f,0xef,
        0xc3,0x33,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xec,0x33,0xfc,0xd8,0xf1,0x22,
        0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0x74,0x02,0x93,0xfe,0x74,0x03,0x93,0xff,
        0x22,0xec,0xf6,0x08,0xed,0xf6,0x08,0xee,0xf6,0x08,0xef,0xf6,0x22,0xd0,0x83,
        0xd0,0x82,0xe4,0x93,0xf6,0x08,0x74,0x01,0x93,0xf6,0x08,0x74,0x02,0x93,0xf6,
        0x08,0x74,0x03,0x93,0xf6,0x74,0x04,0x73,0xa4,0x25,0x82,0xf5,0x82,0xe5,0xf0,
        0x35,0x83,0xf5,0x83,0x22,0xd0,0x83,0xd0,0x82,0xf8,0xe4,0x93,0x70,0x12,0x74,
        0x01,0x93,0x70,0x0d,0xa3,0xa3,0x93,0xf8,0x74,0x01,0x93,0xf5,0x82,0x88,0x83,
        0xe4,0x73,0x74,0x02,0x93,0x68,0x60,0xef,0xa3,0xa3,0xa3,0x80,0xdf,0x85,0x3a,
        0x52,0x90,0x30,0x24,0xe0,0xf5,0x46,0xa3,0xe0,0xf5,0x47,0xa3,0xe0,0xf5,0x48,
        0xa3,0xe0,0xf5,0x49,0xa3,0xe0,0xf5,0x38,0xd2,0x09,0xe5,0x52,0x12,0x06,0xef,
        0x07,0x66,0x03,0x07,0x6c,0x07,0x07,0x7e,0x08,0x08,0x20,0x12,0x07,0xfc,0x80,
        0x07,0xfc,0x81,0x07,0x9c,0x8f,0x07,0xc3,0x90,0x07,0xc3,0x91,0x07,0xc3,0x92,
        0x07,0xc3,0x93,0x07,0xc3,0x94,0x07,0xdf,0x98,0x07,0xf4,0x9f,0x08,0x31,0xec,
        0x00,0x00,0x08,0x4f,0xe4,0xf5,0x20,0xd2,0x0d,0x22,0x85,0x4d,0x46,0x85,0x4e,
        0x47,0x85,0x4f,0x48,0x85,0x50,0x49,0x85,0x51,0x38,0x02,0x08,0x34,0x75,0x20,
        0x70,0xc2,0x0d,0xe4,0xf5,0x40,0x90,0x0e,0x33,0x12,0x08,0x50,0x90,0x0e,0x32,
        0xe4,0x12,0x08,0x50,0xe4,0xf5,0x09,0x12,0x0b,0xfd,0x02,0x08,0x34,0x12,0x09,
        0x76,0x50,0x03,0x02,0x08,0x34,0x75,0x20,0x16,0xe4,0xf5,0x4a,0xf5,0x4b,0xf5,
        0x38,0xe5,0x38,0x12,0x09,0x39,0x12,0x06,0xca,0x28,0x1e,0x28,0x1e,0x05,0x38,
        0xe5,0x38,0xb4,0x05,0xed,0x80,0x71,0xe5,0x20,0x64,0x16,0x70,0x6b,0xaf,0x49,
        0xae,0x48,0xad,0x47,0xac,0x46,0xe5,0x52,0x25,0xe0,0x25,0xe0,0x24,0xe2,0xf8,
        0x12,0x06,0xbe,0x80,0x55,0xe5,0x20,0x64,0x16,0x70,0x4f,0x85,0x46,0x3b,0x85,
        0x47,0x3c,0x85,0x48,0x3d,0x85,0x49,0x3e,0x85,0x38,0x3f,0xe5,0x20,0x64,0x16,
        0x70,0x3a,0x80,0x2c,0x12,0x09,0x76,0x40,0x33,0xe5,0x20,0x64,0x16,0x60,0x2d,
        0x75,0x20,0x16,0x12,0x0d,0xce,0xe5,0x52,0xb4,0x81,0x06,0x85,0x46,0x4a,0x85,
        0x47,0x4b,0xe4,0xf5,0x09,0x12,0x0b,0x70,0x80,0x08,0x12,0x09,0x76,0x40,0x0f,
        0x75,0x20,0x16,0x75,0x09,0x01,0x12,0x0b,0x70,0xd2,0x08,0x22,0x12,0x0e,0x86,
        0x90,0x30,0x24,0xe5,0x46,0xf0,0xa3,0xe5,0x47,0xf0,0xa3,0xe5,0x48,0xf0,0xa3,
        0xe5,0x49,0xf0,0xa3,0xe5,0x38,0xf0,0x90,0x30,0x23,0xe4,0xf0,0x22,0x93,0xf5,
        0x37,0x75,0x09,0x02,0x12,0x0b,0xfd,0x22,0xe5,0x09,0x25,0xe0,0x25,0xe0,0x24,
        0x24,0xf8,0xe6,0x75,0x83,0x00,0xf5,0x82,0xe5,0x09,0x25,0xe0,0x25,0xe0,0x24,
        0x25,0xf8,0xe6,0xfd,0x7c,0x00,0xaf,0x82,0x7e,0x00,0x12,0x04,0xf3,0x8e,0x83,
        0x8f,0x82,0xe5,0x82,0x45,0x83,0x22,0xf8,0xa6,0x07,0xeb,0x25,0xe0,0x25,0xe0,
        0x24,0x25,0xf8,0xe6,0xff,0xeb,0x25,0xe0,0x25,0xe0,0x22,0x12,0x06,0x9b,0xe5,
        0x49,0x2f,0xf5,0x49,0xe5,0x48,0x3e,0xf5,0x48,0xe5,0x47,0x3d,0xf5,0x47,0xe5,
        0x46,0x3c,0xf5,0x46,0x22,0x74,0x4d,0x2b,0xf8,0xe6,0xd3,0x94,0x00,0x22,0xee,
        0x75,0xf0,0x0a,0xa4,0x24,0x6d,0xf8,0x22,0x8f,0x82,0x8e,0x83,0x75,0xf0,0x04,
        0xed,0x02,0x06,0xe3,0x74,0x4d,0x2f,0xf8,0xe6,0xd3,0x94,0x00,0x22,0xe9,0x24,
        0x01,0xfd,0xe4,0x33,0xfc,0xee,0xfb,0xc3,0xed,0x9b,0x74,0x80,0xf8,0x6c,0x98,
        0x22,0x12,0x05,0x5a,0x8f,0x0d,0x8e,0x0c,0x8d,0x0b,0x8c,0x0a,0x22,0xef,0x25,
        0xe0,0x28,0xf8,0xe6,0xfc,0x08,0xe6,0xfd,0x74,0x68,0x2f,0xf8,0x22,0x8f,0x0d,
        0x8e,0x0c,0x8d,0x0b,0x8c,0x0a,0x22,0xf8,0xe6,0xf5,0x09,0x08,0xe6,0xf5,0x0a,
        0x22,0xef,0x75,0xf0,0x0a,0xa4,0x24,0x6e,0xf8,0xeb,0x25,0xe0,0x28,0xf9,0x22,
        0xeb,0x25,0xe0,0x24,0xa0,0xf9,0x22,0xf8,0xe6,0xf9,0xd3,0x9d,0xec,0x64,0x80,
        0xf8,0x74,0x80,0x98,0x22,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x22,0xf8,0x22,0x78,
        0xdb,0xe6,0x25,0x36,0xf5,0x36,0x22,0x25,0x4c,0xf8,0xe6,0x24,0xd1,0xf8,0xe6,
        0x22,0xc3,0xe5,0x10,0x9f,0xf5,0x10,0xe5,0x0f,0x9e,0xf5,0x0f,0x22,0xc3,0xe5,
        0x12,0x9f,0xf5,0x12,0xe5,0x11,0x9e,0xf5,0x11,0x22,0x75,0xf0,0x08,0xa4,0x24,
        0x8b,0xf8,0xe6,0xfe,0x08,0xe6,0x22,0xe5,0x20,0x54,0x7f,0xc3,0x94,0x10,0x22,
        0x78,0xdb,0xa6,0x07,0xc3,0xe5,0x36,0x96,0xf5,0x36,0x22,0xe0,0xa3,0xe0,0x75,
        0xf0,0x02,0xa4,0xff,0xae,0xf0,0x22,0x25,0x0e,0xf8,0xe6,0xff,0xe4,0xfc,0xfd,
        0xfe,0x22,0x75,0xa8,0x07,0x75,0xb8,0x04,0x75,0x09,0xff,0x75,0x0a,0x0e,0x75,
        0x0b,0x02,0x75,0x0c,0x09,0x12,0x0f,0x68,0xd2,0xaf,0x75,0x09,0xff,0x75,0x0a,
        0x0e,0x75,0x0b,0x26,0x75,0x0c,0x03,0x12,0x0f,0x68,0x12,0x0d,0xce,0xe4,0xf5,
        0x09,0x12,0x0b,0x70,0x75,0x09,0x01,0x12,0x0b,0x70,0x12,0x00,0x16,0xc2,0x08,
        0xd2,0x09,0x75,0x20,0x70,0x30,0x0e,0x05,0xc2,0x0e,0x12,0x07,0x15,0x30,0x08,
        0x15,0xe5,0x20,0xb4,0x16,0x0e,0x12,0x0a,0xb0,0x12,0x00,0x16,0x75,0x20,0x70,
        0x90,0x30,0x23,0xe4,0xf0,0xc2,0x08,0x20,0x0c,0x03,0x02,0x0a,0xa0,0xc2,0x0d,
        0x30,0x07,0x05,0xc2,0x07,0x02,0x0a,0x9c,0xe5,0x20,0x70,0x05,0x12,0x0f,0xa8,
        0x80,0x71,0x74,0x05,0xd3,0x95,0x20,0x40,0x02,0x80,0x17,0xe5,0x20,0xb4,0x05,
        0x0b,0x14,0xf5,0x09,0x12,0x0d,0x69,0x12,0x02,0xce,0x80,0x58,0x74,0x0a,0xd3,
        0x95,0x20,0x40,0x0b,0x12,0x0f,0xf4,0x12,0x0a,0xa9,0xe5,0x20,0x14,0x80,0x2e,
        0xe5,0x20,0xb4,0x0a,0x15,0x14,0xf5,0x09,0x12,0x0d,0x69,0x12,0x0f,0x20,0x12,
        0x0a,0xa9,0x90,0x0e,0x34,0xe4,0x93,0xf5,0x37,0x80,0x41,0x74,0x0d,0xd3,0x95,
        0x20,0x40,0x16,0x12,0x0f,0xe2,0x75,0x09,0x02,0x12,0x0b,0xfd,0xe5,0x20,0x24,
        0xf5,0xf5,0x09,0x12,0x0d,0x69,0x05,0x20,0x80,0x24,0xe5,0x20,0xb4,0x0d,0x12,
        0x24,0xf5,0xf5,0x09,0x12,0x0d,0x69,0x12,0x0c,0x80,0x75,0x09,0x02,0x12,0x0b,
        0xfd,0x80,0x0d,0xe5,0x20,0xb4,0x0e,0x08,0x12,0x0d,0xf9,0x90,0x30,0x23,0xe4,
        0xf0,0xc2,0x0c,0xd2,0x0d,0x90,0x30,0x29,0xe5,0x20,0xf0,0x02,0x09,0xdd,0x75,
        0x09,0x02,0x12,0x0b,0xfd,0x22,0xe4,0x75,0x0d,0xff,0x75,0x0c,0xff,0xf5,0x0b,
        0xf5,0x0a,0xf5,0x09,0x74,0x3b,0x25,0x09,0xf8,0xe6,0x60,0x16,0x12,0x08,0x5a,
        0x60,0x11,0xc3,0xe5,0x82,0x95,0x0d,0xe5,0x83,0x95,0x0c,0x50,0x06,0x85,0x83,
        0x0c,0x85,0x82,0x0d,0x05,0x09,0xe5,0x09,0xb4,0x05,0xdb,0xe4,0x7f,0x01,0xfe,
        0xfd,0xfc,0xab,0x0d,0xaa,0x0c,0xa9,0x0b,0xa8,0x0a,0xc3,0x12,0x06,0x77,0x50,
        0x0a,0xe4,0x75,0x0d,0x01,0xf5,0x0c,0xf5,0x0b,0xf5,0x0a,0xaf,0x0d,0xae,0x0c,
        0xad,0x0b,0xac,0x0a,0xe4,0x7b,0x80,0xfa,0xf9,0xf8,0x12,0x05,0x5a,0x8f,0x0d,
        0x8e,0x0c,0x8d,0x0b,0x8c,0x0a,0xe4,0xf5,0x09,0x74,0x3b,0x25,0x09,0xf8,0xe6,
        0x70,0x02,0x80,0x2f,0x12,0x08,0x5a,0x70,0x09,0x74,0x41,0x25,0x09,0xf8,0x76,
        0x80,0x80,0x33,0xab,0x82,0xaa,0x83,0xe4,0xf9,0xf8,0xaf,0x0d,0xae,0x0c,0xad,
        0x0b,0xac,0x0a,0x12,0x05,0xe5,0x8e,0x83,0x8f,0x82,0xc3,0xe5,0x82,0x94,0x01,
        0xe5,0x83,0x94,0x00,0x50,0x09,0x74,0x41,0x25,0x09,0xf8,0x76,0x01,0x80,0x09,
        0xaf,0x82,0x74,0x41,0x25,0x09,0xf8,0xa6,0x07,0x05,0x09,0xe5,0x09,0x64,0x05,
        0x70,0xad,0x22,0xe4,0xfb,0xe5,0x09,0x70,0x2d,0xeb,0x25,0xe0,0x25,0xe0,0x24,
        0x65,0xf5,0x82,0xe4,0x34,0x0e,0xf5,0x83,0x12,0x06,0xae,0x12,0x09,0x38,0x12,
        0x06,0xbe,0x12,0x09,0x38,0xe5,0x4a,0x26,0xf6,0xeb,0x25,0xe0,0x25,0xe0,0x24,
        0x23,0xf8,0xe5,0x4b,0x26,0xf6,0x02,0x0b,0xf3,0xe5,0x09,0x64,0x01,0x70,0x4a,
        0xeb,0x25,0xe0,0x25,0xe0,0x24,0x24,0x12,0x08,0x90,0x24,0x22,0xf8,0xe6,0xc3,
        0x9f,0x12,0x08,0x92,0x24,0x6d,0x12,0x08,0x86,0x24,0x23,0xf8,0xe6,0xc3,0x9f,
        0x12,0x08,0x92,0x24,0x6e,0xf8,0xa6,0x07,0xeb,0x25,0xe0,0x25,0xe0,0x24,0x24,
        0x12,0x08,0x90,0x24,0x22,0xf8,0xe6,0x2f,0x12,0x08,0x92,0x24,0x6f,0x12,0x08,
        0x86,0x24,0x23,0xf8,0xe6,0x2f,0x12,0x08,0x92,0x24,0x70,0xf8,0xa6,0x07,0x0b,
        0xeb,0x64,0x05,0x60,0x03,0x02,0x0b,0x72,0x22,0xe5,0x09,0x60,0x68,0xd3,0x94,
        0x01,0x40,0x08,0xe5,0x36,0x90,0x0e,0x3c,0x93,0xf5,0x40,0x90,0x0e,0x38,0xe4,
        0x93,0xfe,0x74,0x01,0x93,0xff,0xc3,0x90,0x0e,0x36,0x74,0x01,0x93,0x9f,0xff,
        0xe4,0x93,0x9e,0xfe,0xe4,0x8f,0x0d,0x8e,0x0c,0xf5,0x0b,0xf5,0x0a,0xab,0x0d,
        0xaa,0x0c,0xa9,0x0b,0xa8,0x0a,0xaf,0x40,0xfc,0xfd,0xfe,0x12,0x05,0x5a,0x12,
        0x09,0x04,0xe4,0x7b,0xff,0xfa,0xf9,0xf8,0x12,0x05,0xe5,0x12,0x09,0x04,0x78,
        0x04,0x12,0x06,0x9b,0x12,0x09,0x04,0xe5,0x0d,0x45,0x37,0xf5,0x0d,0xe5,0x0c,
        0xf5,0x0c,0xe5,0x0b,0xf5,0x0b,0xe5,0x0a,0xf5,0x0a,0x80,0x0c,0xe4,0xf5,0x0d,
        0x75,0x0c,0x80,0xf5,0x0b,0xf5,0x0a,0xf5,0x36,0x90,0x36,0x02,0xe5,0x0d,0xf0,
        0xa3,0xe5,0x0c,0xf0,0x22,0xe4,0xf5,0x0d,0xf5,0x0e,0x75,0x0f,0x03,0x12,0x0e,
        0xd8,0xe4,0xf5,0x0c,0xf5,0x0b,0xff,0x12,0x08,0xce,0x50,0x10,0xef,0x65,0x4c,
        0x60,0x0b,0x05,0x0c,0x74,0x68,0x2f,0xf8,0xe6,0x25,0x0b,0xf5,0x0b,0x0f,0xbf,
        0x05,0xe7,0xe5,0x0c,0xc3,0x13,0x25,0x0b,0xf5,0x0b,0x85,0x0c,0xf0,0x84,0xf5,
        0x0b,0xfe,0x24,0x01,0xfd,0xe4,0x33,0xfc,0x74,0x68,0x25,0x4c,0x12,0x09,0x2b,
        0x50,0x05,0x12,0x08,0xd7,0x50,0x02,0xae,0x01,0xe4,0xff,0x12,0x08,0xce,0x50,
        0x1a,0xee,0x24,0x01,0xfd,0xe4,0x33,0xfc,0x74,0x68,0x2f,0x12,0x09,0x2b,0x50,
        0x05,0x12,0x08,0xd7,0x50,0x06,0x74,0x4d,0x2f,0xf8,0x76,0x05,0x0f,0xbf,0x05,
        0xdd,0x74,0xd1,0x2e,0xf8,0xe6,0xf5,0x36,0x75,0x20,0x8e,0x22,0xc0,0xe0,0xc0,
        0x83,0xc0,0x82,0x90,0x3f,0x0c,0xe0,0xf5,0x08,0xe5,0x08,0x30,0xe3,0x37,0x30,
        0x0d,0x34,0x90,0x60,0x19,0xe0,0xf5,0x54,0xa3,0xe0,0xf5,0x55,0x90,0x60,0x21,
        0xe0,0xf5,0x56,0xa3,0xe0,0xf5,0x57,0x90,0x60,0x29,0xe0,0xf5,0x58,0xa3,0xe0,
        0xf5,0x59,0x90,0x60,0x31,0xe0,0xf5,0x5a,0xa3,0xe0,0xf5,0x5b,0x90,0x60,0x39,
        0xe0,0xf5,0x5c,0xa3,0xe0,0xf5,0x5d,0xd2,0x0c,0xe5,0x08,0x30,0xe1,0x10,0x30,
        0x09,0x0d,0x90,0x30,0x22,0xe0,0x75,0x39,0x00,0xf5,0x3a,0xe4,0xf0,0xd2,0x0e,
        0x90,0x3f,0x0c,0xe5,0x08,0xf0,0xd0,0x82,0xd0,0x83,0xd0,0xe0,0x32,0xe4,0xf5,
        0x0e,0xe5,0x0e,0x25,0xe0,0x24,0x54,0xf8,0xe6,0xfe,0x08,0xe6,0xff,0xe4,0x8f,
        0x0d,0x8e,0x0c,0xf5,0x0b,0xf5,0x0a,0xab,0x0d,0xaa,0x0c,0xa9,0x0b,0xa8,0x0a,
        0xc0,0x00,0x74,0x3b,0x12,0x09,0x94,0xd0,0x00,0x12,0x08,0xe9,0xab,0x0d,0xaa,
        0x0c,0xa9,0x0b,0xa8,0x0a,0xc0,0x00,0x74,0x41,0x12,0x09,0x94,0xd0,0x00,0x12,
        0x08,0xe9,0xe4,0x7b,0x80,0xfa,0xf9,0xf8,0x12,0x05,0xe5,0x12,0x08,0xec,0xe5,
        0x09,0x12,0x08,0xbb,0xe5,0x0e,0x25,0xe0,0x28,0xf8,0xa6,0x0c,0x08,0xa6,0x0d,
        0x05,0x0e,0xe5,0x0e,0x64,0x05,0x70,0x9f,0x22,0x90,0x0e,0x63,0xe4,0x93,0xf5,
        0x4a,0xa3,0xe4,0x93,0xf5,0x4b,0xe4,0xff,0xef,0x90,0x0e,0x79,0x93,0xfe,0x74,
        0x3b,0x2f,0xf8,0xa6,0x06,0xef,0x90,0x0e,0x7e,0x93,0xfe,0x74,0x41,0x2f,0xf8,
        0xa6,0x06,0x0f,0xbf,0x05,0xe4,0x22,0x75,0x20,0x10,0x22,0x00,0x00,0x00,0x56,
        0x40,0x30,0x04,0x20,0xdf,0x30,0x05,0x40,0xbf,0x50,0x25,0x04,0xfb,0x60,0x00,
        0x11,0x00,0x3f,0x05,0x30,0x00,0x3f,0x06,0x22,0x00,0x3f,0x01,0x29,0x00,0x3f,
        0x02,0x00,0x00,0x3f,0x0b,0x0f,0xf0,0x30,0x01,0x40,0xbf,0x30,0x01,0x00,0xbf,
        0x30,0x29,0x7e,0x00,0x00,0x02,0x04,0x06,0x03,0x66,0x00,0x00,0x00,0x24,0x1e,
        0x23,0x28,0x2d,0x32,0x37,0x3c,0x41,0x46,0x4b,0x50,0x55,0x5a,0x5f,0x64,0x69,
        0x6e,0x73,0x78,0x7e,0x84,0x8a,0x90,0x96,0x9c,0xa3,0xaa,0xb1,0xb8,0xbf,0xc6,
        0xcd,0xd5,0xde,0xe8,0xf3,0xff,0x50,0x3c,0x20,0x18,0x08,0x09,0x08,0x03,0x04,
        0x06,0x04,0x06,0x08,0x06,0x08,0x06,0x0c,0x06,0x04,0x06,0x08,0x03,0x08,0x03,
        0x04,0x04,0x08,0x04,0x04,0x80,0x80,0x80,0x80,0x80,0x0a,0x0c,0x10,0xe5,0x49,
        0x24,0xf2,0xf5,0x0c,0xe5,0x48,0x34,0x43,0xf5,0x0b,0xe5,0x47,0x34,0xa2,0xf5,
        0x0a,0xe5,0x46,0x34,0x28,0xf5,0x09,0x85,0x0c,0x46,0xe5,0x0c,0x54,0xa0,0xff,
        0xe5,0x0b,0xfe,0xe4,0xfd,0xfc,0x78,0x07,0x12,0x06,0x88,0x78,0x10,0x12,0x08,
        0x99,0xe4,0xff,0xfe,0xe5,0x0a,0xfd,0xe4,0xfc,0x78,0x0e,0x12,0x06,0x88,0x12,
        0x08,0x9c,0xe4,0xff,0xfe,0xfd,0xe5,0x09,0xfc,0x78,0x18,0x12,0x06,0x88,0x78,
        0x08,0x12,0x08,0x99,0x22,0xe4,0xff,0x74,0x68,0x2f,0xf8,0xe4,0xf6,0x12,0x08,
        0xce,0x50,0x34,0xe5,0x0d,0x12,0x08,0xbb,0x12,0x08,0xf5,0xe4,0xf6,0xae,0x0d,
        0xee,0xc3,0x95,0x0f,0xe4,0x95,0x0e,0x50,0x1f,0x12,0x08,0xba,0xef,0x25,0xe0,
        0x28,0xf8,0xe6,0xfa,0x08,0xe6,0xfb,0xd3,0xed,0x9b,0xec,0x9a,0x50,0x08,0x12,
        0x08,0xba,0x12,0x08,0xf5,0xa6,0x06,0x0e,0x80,0xd8,0x0f,0xef,0x64,0x05,0x70,
        0xbb,0x22,0x75,0x0d,0x05,0x75,0x0e,0x00,0x75,0x0f,0x0a,0x12,0x0e,0xd8,0xe4,
        0xff,0x12,0x08,0xce,0x50,0x13,0x74,0x68,0x25,0x4c,0xf9,0x74,0x68,0x2f,0xf8,
        0xe6,0x67,0x60,0x06,0x74,0x4d,0x2f,0xf8,0x76,0x04,0x0f,0xbf,0x05,0xe4,0x74,
        0x68,0x12,0x09,0x49,0xf5,0x36,0x30,0x0b,0x04,0x7f,0x01,0x80,0x02,0x7f,0xff,
        0x12,0x09,0x7e,0x74,0xc7,0x25,0x20,0xf8,0xa6,0x36,0x75,0x20,0x8b,0x22,0xae,
        0x0a,0xaf,0x0b,0xe4,0xfd,0xed,0xc3,0x95,0x0c,0x50,0x33,0x12,0x08,0xc3,0xe4,
        0x93,0xf5,0x0d,0x74,0x01,0x93,0xf5,0x0e,0x45,0x0d,0x60,0x23,0x85,0x0e,0x82,
        0x85,0x0d,0x83,0xe0,0xfc,0x12,0x08,0xc3,0x74,0x03,0x93,0x52,0x04,0x12,0x08,
        0xc3,0x74,0x02,0x93,0x42,0x04,0x85,0x0e,0x82,0x85,0x0d,0x83,0xec,0xf0,0x0d,
        0x80,0xc7,0x22,0xe5,0x40,0xc3,0x94,0x69,0x50,0x02,0x80,0x01,0xc3,0x92,0x0b,
        0x90,0x0e,0x33,0xe4,0x93,0xf5,0x37,0x30,0x0b,0x04,0x7f,0x06,0x80,0x02,0x7f,
        0xfa,0x78,0xdb,0xa6,0x07,0x30,0x0b,0x05,0x90,0x0e,0x3a,0x80,0x03,0x90,0x0e,
        0x3b,0xe4,0x93,0xff,0x8f,0x36,0x12,0x09,0x41,0x78,0xd1,0xf6,0x75,0x20,0x81,
        0x22,0x90,0x0e,0x35,0xe4,0x93,0xf5,0x37,0x12,0x09,0x41,0x74,0xc7,0x25,0x20,
        0xf8,0xa6,0x36,0x22,0x12,0x09,0x41,0x74,0xd1,0x25,0x20,0xf8,0xa6,0x36,0x22
    };
#endif
    kal_uint16 i;

    CamWriteCmosSensor(0x3000, 0x30);
    for (i = 0; i < sizeof(AfFw1p01) / sizeof(AfFw1p01[0]); i++)
    {
        CamWriteCmosSensor(0x8000 + i, AfFw1p01[i]);
    }
    CamWriteCmosSensor(0x3022, 0x00);
    CamWriteCmosSensor(0x3023, 0x00);
    CamWriteCmosSensor(0x3024, 0x00);
    CamWriteCmosSensor(0x3025, 0x00);
    CamWriteCmosSensor(0x3026, 0x00);
    CamWriteCmosSensor(0x3027, 0x00);
    CamWriteCmosSensor(0x3028, 0x00);
    CamWriteCmosSensor(0x3029, 0x7F);
    CamWriteCmosSensor(0x3000, 0x10);
    i = 1001;
    while (--i > 0 && OV5640AfGetState() != 0x70) /* check if in idle state */
    {
        kal_sleep_task(1);
    }
    if (!i)
    {
        OV5640_TRACE("AF idle time out!!!");
    }
#endif
}

/*************************************************************************
* FUNCTION
*   OV5640FlashMode
*
* DESCRIPTION
*   flash mode
*
* PARAMETERS
*   In, Out
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640FlashMode(P_CAL_FEATURE_CTRL_STRUCT In, P_CAL_FEATURE_CTRL_STRUCT Out)
{
    if (CAL_FEATURE_QUERY_OPERATION == In->FeatureCtrlCode)
    {
        const P_CAL_FEATURE_TYPE_ENUM_STRUCT FlashMode = &Out->FeatureInfo.FeatureEnum;

        Out->FeatureType = CAL_FEATURE_TYPE_ENUMERATE;
        Out->FeatureOperationSupport = CAL_FEATURE_SET_OPERATION|CAL_FEATURE_QUERY_OPERATION;
        Out->FeatureModeSupport = CAL_FEATURE_CAMERA_SUPPORT;
        // TODO: add supported flash mode enum here
#ifndef LED_FLASHLIGHT_SUPPORT
        FlashMode->IsSupport = KAL_FALSE;
#else
        FlashMode->IsSupport = KAL_TRUE;
        FlashMode->ItemCount = 4;
        FlashMode->SupportItem[0] = CAM_FLASH_OFF;
        FlashMode->SupportItem[1] = CAM_FLASH_ON;
        FlashMode->SupportItem[2] = CAM_FLASH_AUTO;
        FlashMode->SupportItem[3] = CAM_FLASH_REDEYE;
#endif
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640FlashTriggerCheck
*
* DESCRIPTION
*   This function check the average Y and
*     threshhold to determine if need to trigger flashlight
*
* PARAMETERS
*   None
*
* RETURNS
*   Enable: KAL_TRUE: need trigger, KAL_FALSE: do nothing
*
* LOCAL AFFECTED
*
*************************************************************************/
static kal_bool OV5640FlashTriggerCheck(void)
{
    kal_bool NeedTrigger = KAL_FALSE;
    kal_uint32 Shutter = 0;
    kal_uint32 Gain = 0;
    kal_uint32 Yaverage = 0;
    kal_uint32 Yup=0;
    kal_uint32 Ydown=0;

    ///TODO: check the average Y and threshhold to determine if need to trigger flashlight
    //1: read shutter
    //2: read gain
    //3: determine if trigger flash
    Shutter = OV5640ReadShutter();
    Gain = OV5640ReadGain();
    Yaverage = CamReadCmosSensor(0x56A1);
    Yup = CamReadCmosSensor(0x3A1B);
    Ydown = CamReadCmosSensor(0x3A1E);

    if (Shutter > 6250)
    {
        NeedTrigger = KAL_TRUE;
    }
    if (Gain > 5 * 64) /* 5x */
    {
        NeedTrigger = KAL_TRUE;
    }
    if (Gain * Shutter > 3 * 64 * 6250) /* 3x */
    {
        NeedTrigger = KAL_TRUE;
    }

    return NeedTrigger;
}

/*************************************************************************
* FUNCTION
*   OV5640InitialSetting
*
* DESCRIPTION
*   This function initialize the registers of CMOS sensor
*   IMPORTANT NOTICE:
*     the output format should be YUV422, order: YUYV
*     data output should be at pclk falling edge
*     VSYNC should be low active
*     HSYNC should be hight active
*
* PARAMETERS
*   None
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640InitialSetting(void)
{
    // TODO: add initial code here
/* if defined, means use internal DVDD, and DOVDD should be 1.8V */
#define OV5640_INTERNAL_DVDD

    CamWriteCmosSensor(0x3103, 0x03); /* pclk select */
    CamWriteCmosSensor(0x3008, 0x82); /* [7]: software reset */
    kal_sleep_task(1);
    CamWriteCmosSensor(0x3017, 0x7F); /* pad output enable 01 */
    CamWriteCmosSensor(0x3018, 0xFC); /* pad output enable 02 */

#if !defined(OV5640_INTERNAL_DVDD)
    CamWriteCmosSensor(0x3030, 0x2B); /* use external regulator */
#endif
    CamWriteCmosSensor(0x3000, 0x10); /* disable block: OTP */
    CamWriteCmosSensor(0x3001, 0x08); /* disable block: S2P */
    CamWriteCmosSensor(0x3002, 0x5C); /* disable block: JFIFO, SFIFO, jpeg */
    CamWriteCmosSensor(0x3003, 0x02); /* disable block: MIPI */
    CamWriteCmosSensor(0x3004, 0xEF); /* disable clock: OTP */
    CamWriteCmosSensor(0x3005, 0xF7); /* disable clock: S2P */
    CamWriteCmosSensor(0x3006, 0xC3); /* disable clock: jpg 2x, jpg */
    CamWriteCmosSensor(0x3007, 0xE7); /* disable clock: MIPI */

    /* pll setting */
    CamWriteCmosSensor(0x3035, 0x61);
    CamWriteCmosSensor(0x3036, 0x53);
    CamWriteCmosSensor(0x3037, 0x03);
    CamWriteCmosSensor(0x3824, 0x01);
    CamWriteCmosSensor(0x3108, 0x01); /* [1:0]: sclk_rdiv */
    CamWriteCmosSensor(0x3034, 0x1A); /* [3:0]: bit_div */
    CamWriteCmosSensor(0x300E, 0x58); /* MIPI ctrl */
    CamWriteCmosSensor(0x460C, 0x22); /* pclk manual enable */
    CamWriteCmosSensor(0x303B, 0x18); /* PLLS multiplier */

    CamWriteCmosSensor(0x3630, 0x2e);
    CamWriteCmosSensor(0x3632, 0xe2);
    CamWriteCmosSensor(0x3633, 0x23);
    CamWriteCmosSensor(0x3621, 0xe0);
    CamWriteCmosSensor(0x3704, 0xa0);
    CamWriteCmosSensor(0x3703, 0x5a);
    CamWriteCmosSensor(0x3715, 0x78);
    CamWriteCmosSensor(0x3717, 0x01);
    CamWriteCmosSensor(0x370b, 0x60);
    CamWriteCmosSensor(0x3705, 0x1a);
    CamWriteCmosSensor(0x3905, 0x02);
    CamWriteCmosSensor(0x3906, 0x10);
    CamWriteCmosSensor(0x3901, 0x0a);
    CamWriteCmosSensor(0x3731, 0x12);
    CamWriteCmosSensor(0x3600, 0x08);
    CamWriteCmosSensor(0x3601, 0x33);
    CamWriteCmosSensor(0x302d, 0x60);
    CamWriteCmosSensor(0x3620, 0x52);
    CamWriteCmosSensor(0x371B, 0x20);
    CamWriteCmosSensor(0x471C, 0x50);
    CamWriteCmosSensor(0x471D, 0x00); /* VSYNC auto trigger */
    CamWriteCmosSensor(0x3635, 0x1c);
    CamWriteCmosSensor(0x3634, 0x40);
    CamWriteCmosSensor(0x3622, 0x01);
    CamWriteCmosSensor(0x3C01, 0x80); /* auto FD: disable */

    /* window */
    CamWriteCmosSensor(0x3820, 0x41);
    CamWriteCmosSensor(0x3821, 0x07);
    CamWriteCmosSensor(0x3814, 0x31);
    CamWriteCmosSensor(0x3815, 0x31);
    CamWriteCmosSensor(0x3800, 0x00);
    CamWriteCmosSensor(0x3801, 0x00);
    CamWriteCmosSensor(0x3802, 0x00);
    CamWriteCmosSensor(0x3803, 0x04);
    CamWriteCmosSensor(0x3804, 0x0A);
    CamWriteCmosSensor(0x3805, 0x3F);
    CamWriteCmosSensor(0x3806, 0x07);
    CamWriteCmosSensor(0x3807, 0x9B);
    CamWriteCmosSensor(0x3808, 0x02);
    CamWriteCmosSensor(0x3809, 0x80);
    CamWriteCmosSensor(0x380a, 0x01);
    CamWriteCmosSensor(0x380b, 0xE0);
    CamWriteCmosSensor(0x380c, 0x07);
    CamWriteCmosSensor(0x380d, 0x68);
    CamWriteCmosSensor(0x380e, 0x03);
    CamWriteCmosSensor(0x380f, 0xd8);
    CamWriteCmosSensor(0x3810, 0x00);
    CamWriteCmosSensor(0x3811, 0x10);
    CamWriteCmosSensor(0x3812, 0x00);
    CamWriteCmosSensor(0x3813, 0x06);
    CamWriteCmosSensor(0x3618, 0x00);
    CamWriteCmosSensor(0x3612, 0x29);
    CamWriteCmosSensor(0x3708, 0x62);
    CamWriteCmosSensor(0x3709, 0x52);
    CamWriteCmosSensor(0x370c, 0x03);
    CamWriteCmosSensor(0x3a02, 0x03);
    CamWriteCmosSensor(0x3a03, 0xd8);
    CamWriteCmosSensor(0x3a08, 0x01);
    CamWriteCmosSensor(0x3a09, 0x27);
    CamWriteCmosSensor(0x3a0a, 0x00);
    CamWriteCmosSensor(0x3a0b, 0xf6);
    CamWriteCmosSensor(0x3a0e, 0x03);
    CamWriteCmosSensor(0x3a0d, 0x04);
    CamWriteCmosSensor(0x3a14, 0x03);
    CamWriteCmosSensor(0x3a15, 0xd8);

    CamWriteCmosSensor(0x4001, 0x02); /* BLC start line */
    CamWriteCmosSensor(0x4004, 0x02); /* BLC line number */
    CamWriteCmosSensor(0x4005, 0x1A); /* BLC always update */
    CamWriteCmosSensor(0x302E, 0x00);
    CamWriteCmosSensor(0x4300, 0x30); /* format: YUV422 */
    CamWriteCmosSensor(0x501F, 0x00); /* format MUX ctrl: isp yuv422 */
    CamWriteCmosSensor(0x460B, 0x35);
    CamWriteCmosSensor(0x5000, 0xA7); /* isp func enable: lenc, raw gamma, black/white pixel cancel, color interpolation */
    CamWriteCmosSensor(0x5001, 0xA3); /* isp func enable: SDE, scale, color matrix, AWB */

    /* AWB */
    CamWriteCmosSensor(0x5180, 0xff);
    CamWriteCmosSensor(0x5181, 0xf2);
    CamWriteCmosSensor(0x5182, 0x00);
    CamWriteCmosSensor(0x5183, 0x14);
    CamWriteCmosSensor(0x5184, 0x25);
    CamWriteCmosSensor(0x5185, 0x24);
    CamWriteCmosSensor(0x5186, 0x10);
    CamWriteCmosSensor(0x5187, 0x13);
    CamWriteCmosSensor(0x5188, 0x10);
    CamWriteCmosSensor(0x5189, 0x75);
    CamWriteCmosSensor(0x518a, 0x60);
    CamWriteCmosSensor(0x518b, 0xdf);
    CamWriteCmosSensor(0x518c, 0xb6);
    CamWriteCmosSensor(0x518d, 0x3f);
    CamWriteCmosSensor(0x518e, 0x4f);
    CamWriteCmosSensor(0x518f, 0x4d);
    CamWriteCmosSensor(0x5190, 0x42);
    CamWriteCmosSensor(0x5191, 0xf8);
    CamWriteCmosSensor(0x5192, 0x04);
    CamWriteCmosSensor(0x5193, 0x70);
    CamWriteCmosSensor(0x5194, 0xf0);
    CamWriteCmosSensor(0x5195, 0xf0);
    CamWriteCmosSensor(0x5196, 0x03);
    CamWriteCmosSensor(0x5197, 0x01);
    CamWriteCmosSensor(0x5198, 0x06);
    CamWriteCmosSensor(0x5199, 0x58);
    CamWriteCmosSensor(0x519a, 0x04);
    CamWriteCmosSensor(0x519b, 0x00);
    CamWriteCmosSensor(0x519c, 0x07);
    CamWriteCmosSensor(0x519d, 0x2b);
    CamWriteCmosSensor(0x519e, 0x38);

    /* CCM */
    CamWriteCmosSensor(0x5381, 0x1c);
    CamWriteCmosSensor(0x5382, 0x5a);
    CamWriteCmosSensor(0x5383, 0x06);
    CamWriteCmosSensor(0x5384, 0x0a);
    CamWriteCmosSensor(0x5385, 0x7e);
    CamWriteCmosSensor(0x5386, 0x88);
    CamWriteCmosSensor(0x5387, 0x7c);
    CamWriteCmosSensor(0x5388, 0x6c);
    CamWriteCmosSensor(0x5389, 0x10);
    CamWriteCmosSensor(0x538a, 0x01);
    CamWriteCmosSensor(0x538b, 0x98);

    /* sharpness & noise */
    CamWriteCmosSensor(0x5308, 0x65); /* manual mode */
    CamWriteCmosSensor(0x5300, 0x09);
    CamWriteCmosSensor(0x5301, 0x11);
    CamWriteCmosSensor(0x5302, 0x0C);
    CamWriteCmosSensor(0x5303, 0x00);
    CamWriteCmosSensor(0x5304, 0x08);
    CamWriteCmosSensor(0x5305, 0x11);
    CamWriteCmosSensor(0x5306, 0x08);
    CamWriteCmosSensor(0x5307, 0x18);
    CamWriteCmosSensor(0x5309, 0x08);
    CamWriteCmosSensor(0x530a, 0x30);
    CamWriteCmosSensor(0x530b, 0x04);
    CamWriteCmosSensor(0x530c, 0x06);

    CamWriteCmosSensor(0x5480, 0x01);
    CamWriteCmosSensor(0x5481, 0x08);
    CamWriteCmosSensor(0x5482, 0x14);
    CamWriteCmosSensor(0x5483, 0x28);
    CamWriteCmosSensor(0x5484, 0x51);
    CamWriteCmosSensor(0x5485, 0x65);
    CamWriteCmosSensor(0x5486, 0x71);
    CamWriteCmosSensor(0x5487, 0x7e);
    CamWriteCmosSensor(0x5488, 0x88);
    CamWriteCmosSensor(0x5489, 0x92);
    CamWriteCmosSensor(0x548a, 0x9b);
    CamWriteCmosSensor(0x548b, 0xab);
    CamWriteCmosSensor(0x548c, 0xba);
    CamWriteCmosSensor(0x548d, 0xd0);
    CamWriteCmosSensor(0x548e, 0xe1);
    CamWriteCmosSensor(0x548f, 0xf3);
    CamWriteCmosSensor(0x5490, 0x11);

    /* UV adjust */
    CamWriteCmosSensor(0x5580, 0x06); /* should be enable contrast&saturation */
    CamWriteCmosSensor(0x5588, 0x41);
    CamWriteCmosSensor(0x5589, 0x12);
    CamWriteCmosSensor(0x558A, 0x00);
    CamWriteCmosSensor(0x558B, 0x58);

    /* Lens shading */
    CamWriteCmosSensor(0x5800, 0x2c);
    CamWriteCmosSensor(0x5801, 0x17);
    CamWriteCmosSensor(0x5802, 0x11);
    CamWriteCmosSensor(0x5803, 0x11);
    CamWriteCmosSensor(0x5804, 0x15);
    CamWriteCmosSensor(0x5805, 0x29);
    CamWriteCmosSensor(0x5806, 0x08);
    CamWriteCmosSensor(0x5807, 0x06);
    CamWriteCmosSensor(0x5808, 0x04);
    CamWriteCmosSensor(0x5809, 0x04);
    CamWriteCmosSensor(0x580a, 0x05);
    CamWriteCmosSensor(0x580b, 0x07);
    CamWriteCmosSensor(0x580c, 0x06);
    CamWriteCmosSensor(0x580d, 0x03);
    CamWriteCmosSensor(0x580e, 0x01);
    CamWriteCmosSensor(0x580f, 0x01);
    CamWriteCmosSensor(0x5810, 0x03);
    CamWriteCmosSensor(0x5811, 0x06);
    CamWriteCmosSensor(0x5812, 0x06);
    CamWriteCmosSensor(0x5813, 0x02);
    CamWriteCmosSensor(0x5814, 0x01);
    CamWriteCmosSensor(0x5815, 0x01);
    CamWriteCmosSensor(0x5816, 0x04);
    CamWriteCmosSensor(0x5817, 0x07);
    CamWriteCmosSensor(0x5818, 0x06);
    CamWriteCmosSensor(0x5819, 0x07);
    CamWriteCmosSensor(0x581a, 0x06);
    CamWriteCmosSensor(0x581b, 0x06);
    CamWriteCmosSensor(0x581c, 0x06);
    CamWriteCmosSensor(0x581d, 0x0e);
    CamWriteCmosSensor(0x581e, 0x31);
    CamWriteCmosSensor(0x581f, 0x12);
    CamWriteCmosSensor(0x5820, 0x11);
    CamWriteCmosSensor(0x5821, 0x11);
    CamWriteCmosSensor(0x5822, 0x11);
    CamWriteCmosSensor(0x5823, 0x21);
    CamWriteCmosSensor(0x5824, 0x12);
    CamWriteCmosSensor(0x5825, 0x28);
    CamWriteCmosSensor(0x5826, 0x39);
    CamWriteCmosSensor(0x5827, 0x29);
    CamWriteCmosSensor(0x5828, 0x27);
    CamWriteCmosSensor(0x5829, 0x39);
    CamWriteCmosSensor(0x582a, 0x24);
    CamWriteCmosSensor(0x582b, 0x33);
    CamWriteCmosSensor(0x582c, 0x24);
    CamWriteCmosSensor(0x582d, 0x39);
    CamWriteCmosSensor(0x582e, 0x28);
    CamWriteCmosSensor(0x582f, 0x21);
    CamWriteCmosSensor(0x5830, 0x40);
    CamWriteCmosSensor(0x5831, 0x21);
    CamWriteCmosSensor(0x5832, 0x17);
    CamWriteCmosSensor(0x5833, 0x17);
    CamWriteCmosSensor(0x5834, 0x13);
    CamWriteCmosSensor(0x5835, 0x11);
    CamWriteCmosSensor(0x5836, 0x24);
    CamWriteCmosSensor(0x5837, 0x27);
    CamWriteCmosSensor(0x5838, 0x28);
    CamWriteCmosSensor(0x5839, 0x28);
    CamWriteCmosSensor(0x583a, 0x28);
    CamWriteCmosSensor(0x583b, 0x28);
    CamWriteCmosSensor(0x583c, 0x14);
    CamWriteCmosSensor(0x583d, 0xee);

    /* ae */
    CamWriteCmosSensor(0x5025, 0x00);

    OV5640AfInit();

    /* add driver current setting here */
    CamWriteCmosSensor(0x302C, 0x42); /* [7:6]ouput driving current:00:1x,01:2x,10:3x,11:4x */
}

/*************************************************************************
* FUNCTION
*   OV5640PvSetting
*
* DESCRIPTION
*   This function apply the preview mode setting, normal the preview size is 1/4 of full size.
*   Ex. 2M (1600 x 1200)
*   Preview: 800 x 600 (use sub-sample or binning to acheive it)
*   Full Size: 1600 x 1200 (output every effective pixels.)
*
* PARAMETERS
*   None
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640PvSetting(void)
{
    // TODO: add preview setting here
    kal_uint8 TimeCtrl1, TimeCtrl;

    CamWriteCmosSensor(0x3618, 0x00); /* repeat write to avoid I2C fail when in webcam!!! */
    CamWriteCmosSensor(0x3618, 0x00);
    CamWriteCmosSensor(0x3612, 0x29);
    CamWriteCmosSensor(0x3708, 0x62);
    CamWriteCmosSensor(0x3709, 0x52);
    CamWriteCmosSensor(0x370c, 0x03);
    CamWriteCmosSensor(0x4004, 0x02); /* BLC line number */

    CamWriteCmosSensor(0x3800, 0x00); /* HREF HS, 0 */
    CamWriteCmosSensor(0x3801, 0x00);
    CamWriteCmosSensor(0x3802, 0x00); /* HREF VS, 4 */
    CamWriteCmosSensor(0x3803, 0x04);
    CamWriteCmosSensor(0x3804, 0x0A); /* HREF HE, 2623 */
    CamWriteCmosSensor(0x3805, 0x3F);
    CamWriteCmosSensor(0x3806, 0x07); /* HREF VE, 1947 */
    CamWriteCmosSensor(0x3807, 0x9B);
#ifdef OV5640_QUARTER_PREVIEW
    CamWriteCmosSensor(0x3808, 0x05); /* output HW, 1296 */
    CamWriteCmosSensor(0x3809, 0x10);
    CamWriteCmosSensor(0x380A, 0x03); /* output HW, 972 */
    CamWriteCmosSensor(0x380B, 0xCC);
#else
    CamWriteCmosSensor(0x3808, 0x02); /* output HW, 640 */
    CamWriteCmosSensor(0x3809, 0x80);
    CamWriteCmosSensor(0x380A, 0x01); /* output HW, 480 */
    CamWriteCmosSensor(0x380B, 0xE0);
#endif
    CamWriteCmosSensor(0x3810, 0x00); /* H offset, 4 */
    CamWriteCmosSensor(0x3811, 0x04);
    CamWriteCmosSensor(0x3812, 0x00); /* V offset, 0 */
    CamWriteCmosSensor(0x3813, 0x00);
    CamWriteCmosSensor(0x3814, 0x31); /* x inc */
    CamWriteCmosSensor(0x3815, 0x31); /* y inc */
    
    TimeCtrl1 = CamReadCmosSensor(0x3820)|0x01; /* time CTRL1, enable vertical binning mode */
    TimeCtrl = CamReadCmosSensor(0x3821)|0x01; /* time CTRL, enable horizontal binning mode */
    TimeCtrl &= 0xDF; /* disable jpeg output */
    CamWriteCmosSensor(0x3820, TimeCtrl1);
    CamWriteCmosSensor(0x3821, TimeCtrl);
}

/*************************************************************************
* FUNCTION
*   OV5640CapSetting
*
* DESCRIPTION
*   This function config capture settting to sensor
*
* PARAMETERS
*   None
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640CapSetting(void)
{
    // TODO: add capture setting here

    kal_uint8 TimeCtrl1, TimeCtrl;

    CamWriteCmosSensor(0x3618, 0x04);
    CamWriteCmosSensor(0x3612, 0x2b);
    CamWriteCmosSensor(0x3708, 0x21);
    CamWriteCmosSensor(0x3709, 0x12);
    CamWriteCmosSensor(0x370c, 0x00);
    CamWriteCmosSensor(0x4004, 0x06); /* BLC line number */
    CamWriteCmosSensor(0x3800, 0x00); /* HREF HS, 0 */
    CamWriteCmosSensor(0x3801, 0x00);
    CamWriteCmosSensor(0x3802, 0x00); /* HREF VS, 0 */
    CamWriteCmosSensor(0x3803, 0x00);
    CamWriteCmosSensor(0x3804, 0x0A); /* HREF HE, 2623 */
    CamWriteCmosSensor(0x3805, 0x3F);
    CamWriteCmosSensor(0x3806, 0x07); /* HREF VE, 1951 */
    CamWriteCmosSensor(0x3807, 0x9F);
    CamWriteCmosSensor(0x3808, 0x0A); /* output HW, 2592 */
    CamWriteCmosSensor(0x3809, 0x20);
    CamWriteCmosSensor(0x380A, 0x07); /* output HW, 1944 */
    CamWriteCmosSensor(0x380B, 0x98);
    CamWriteCmosSensor(0x3810, 0x00); /* H offset, 16 */
    CamWriteCmosSensor(0x3811, 0x10);
    CamWriteCmosSensor(0x3812, 0x00); /* V offset, 4 */
    CamWriteCmosSensor(0x3813, 0x04);
    CamWriteCmosSensor(0x3814, 0x11); /* x inc */
    CamWriteCmosSensor(0x3815, 0x11); /* y inc */
    
    TimeCtrl1 = CamReadCmosSensor(0x3820)&0xFE; /* time CTRL1, disable vertical binning mode */
    TimeCtrl = CamReadCmosSensor(0x3821)&0xDE; /* time CTRL, disable horizontal binning mode */
    CamWriteCmosSensor(0x3820, TimeCtrl1);
    CamWriteCmosSensor(0x3821, TimeCtrl);

}

/*************************************************************************
* FUNCTION
*   OV5640GetSensorInfo
*
* DESCRIPTION
*   This function set sensor infomation
*
* PARAMETERS
*   Info
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640GetSensorInfo(P_IMAGE_SENSOR_GET_SENSOR_INFO_STRUCT Info)
{
    Info->SensorId = OV5640_SENSOR_ID;
    Info->SensorIf = IMAGE_SENSOR_IF_PARALLEL;

    /* data format */
    Info->PreviewNormalDataFormat = IMAGE_SENSOR_DATA_OUT_FORMAT_YUYV;
    Info->PreviewHMirrorDataFormat = IMAGE_SENSOR_DATA_OUT_FORMAT_YUYV;
    Info->PreviewVMirrorDataFormat = IMAGE_SENSOR_DATA_OUT_FORMAT_YUYV;
    Info->PreviewHVMirrorDataFormat = IMAGE_SENSOR_DATA_OUT_FORMAT_YUYV;
    Info->CaptureDataFormat = IMAGE_SENSOR_DATA_OUT_FORMAT_YUYV;

    Info->PreviewMclkFreq = OV5640_MCLK;
    Info->CaptureMclkFreq = OV5640_MCLK;
    Info->VideoMclkFreq = OV5640_MCLK;
    Info->PreviewWidth = OV5640_IMAGE_SENSOR_PV_WIDTH;
    Info->PreviewHeight = OV5640_IMAGE_SENSOR_PV_HEIGHT;
    Info->FullWidth = OV5640_IMAGE_SENSOR_FULL_WIDTH;
    Info->FullHeight = OV5640_IMAGE_SENSOR_FULL_HEIGHT;
    Info->SensorAfSupport = KAL_TRUE;
    Info->SensorFlashSupport = KAL_TRUE;
    Info->PixelClkPolarity = POLARITY_LOW;

    /* HSYNC/VSYNC polarity */
    Info->HsyncPolarity = POLARITY_LOW; /* actually high active when set POLARITY_LOW */
    Info->VsyncPolarity = POLARITY_LOW;

    // TODO: set isp pclk invert here if needed
    /* isp pclk invert switch */
    Info->PixelClkInv = KAL_FALSE;
}

#if defined (__AUTO_SCENE_DETECT_SUPPORT__)
/*************************************************************************
* FUNCTION
*    OV5640GetEvAwbRef
*
* DESCRIPTION
*    This function get sensor Ev/Awb (EV05/EV13) for auto scene detect
*
* PARAMETERS
*    Ref
*
* RETURNS
*    None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640GetEvAwbRef(P_SENSOR_AE_AWB_REF_STRUCT Ref)
{
    Ref->SensorAERef.AeRefLV05Shutter = 2945;
    Ref->SensorAERef.AeRefLV05Gain = 460 * 2; /* 7.1875x, 128 base */
    Ref->SensorAERef.AeRefLV13Shutter = 79;
    Ref->SensorAERef.AeRefLV13Gain = 128 * 2; /* 2x, 128 base */
    Ref->SensorAwbGainRef.AwbRefD65Rgain = 233; /* 1.82x, 128 base */
    Ref->SensorAwbGainRef.AwbRefD65Bgain = 135; /* 1.05x, 128 base */
    Ref->SensorAwbGainRef.AwbRefCWFRgain = 200; /* 1.56x, 128 base */
    Ref->SensorAwbGainRef.AwbRefCWFBgain = 225; /* 1.76x, 128 base */
}

/*************************************************************************
* FUNCTION
*    OV5640GetCurAeAwbInfo
*
* DESCRIPTION
*    This function get sensor cur Ae/Awb for auto scene detect
*
* PARAMETERS
*    Info
*
* RETURNS
*    None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640GetCurAeAwbInfo(P_SENSOR_AE_AWB_CUR_STRUCT Info)
{
    Info->SensorAECur.AeCurShutter = OV5640ReadShutter();
    Info->SensorAECur.AeCurGain = OV5640ReadGain() * 2; /* 128 base */
    Info->SensorAwbGainCur.AwbCurRgain = (((CamReadCmosSensor(0x519F)&0x0F) << 8)|CamReadCmosSensor(0x51A0)) / 8; /* 128 base */
    Info->SensorAwbGainCur.AwbCurBgain = (((CamReadCmosSensor(0x51A3)&0x0F) << 8)|CamReadCmosSensor(0x51A4)) / 8; /* 128 base */
}
#endif

/*************************************************************************
* FUNCTION
*   OV5640PowerOn
*
* DESCRIPTION
*   This function apply the power on sequence and read the sensor ID to check if the I2C
*  communication can work or not.
*
* PARAMETERS
*   None
*
* RETURNS
*   Sensor id
*
* LOCAL AFFECTED
*
*************************************************************************/
static kal_uint32 OV5640PowerOn(void)
{
    static kal_uint8 OV5640I2cAddr[] = {OV5640_WRITE_ID_0,
#if (OV5640_WRITE_ID_1 != 0xFF)
    OV5640_WRITE_ID_1,
#endif
#if (OV5640_WRITE_ID_2 != 0xFF)
    OV5640_WRITE_ID_2,
#endif
#if (OV5640_WRITE_ID_3 != 0xFF)
    OV5640_WRITE_ID_3,
#endif
    };
    kal_uint32 SensorId;
    kal_uint8 i;

    CisModulePowerOn(OV5640Sensor.SensorIdx, KAL_TRUE);
    CameraSccbOpen(CAMERA_SCCB_SENSOR, OV5640_WRITE_ID_0,
    OV5640_I2C_ADDR_BITS, OV5640_I2C_DATA_BITS, OV5640_HW_I2C_SPEED);
    /* add under line if sensor I2C do not support repeat start */
    //CameraSccbDisWR(CAMERA_SCCB_SENSOR);

    // TODO: add hardware reset  by spec here
    {
        kal_sleep_task(2);
        OV5640_SET_PDN_LOW;
        kal_sleep_task(1);
        OV5640_SET_RST_HIGH;
        kal_sleep_task(1);
    }

    for (i = 0; i < sizeof(OV5640I2cAddr) / sizeof(OV5640I2cAddr[0]); i++)
    {
        CameraSccbSetAddr(CAMERA_SCCB_SENSOR, OV5640I2cAddr[i]);

        // TODO: read sensor id here
        {
            SensorId = (CamReadCmosSensor(0x300A) << 8)|CamReadCmosSensor(0x300B);
        }
        if (OV5640_SENSOR_ID == SensorId)
        {
            kal_uint8 Temp;

            /* swap the correct i2c address to first one, it will speed up next time read sensor ID */
            Temp = OV5640I2cAddr[0];
            OV5640I2cAddr[0] = OV5640I2cAddr[i];
            OV5640I2cAddr[i] = Temp;
            break;
        }
    }
    OV5640_TRACE("SENSOR ID: %x", SensorId);
    return SensorId;
}

/*************************************************************************
* FUNCTION
*   OV5640PowerDown
*
* DESCRIPTION
*   This function power down the cmos sensor
*   IMPORTANT NOTICE:
*     data[7:0]/HSYNC/VSYNC/PCLK pin should be in High-Z state after executed this function
*
* PARAMETERS
*   None
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640PowerDown(void)
{
    // TODO: power down sensor by spec here
    OV5640_SET_PDN_HIGH;
    OV5640_SET_RST_LOW;
}

/*************************************************************************
* FUNCTION
*   OV5640Preview
*
* DESCRIPTION
*   This function is the most important functions of (Init, Preview & Capture). 
*   1. Apply preview setting, make sensor output preview resolution, e.g. 800x600 for 2M sensor.
*   2. Record video resolution, and set mode based on the isp operation mode.
*   3. Configure the grab window.
*
* PARAMETERS
*   Id, In, Out
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640Preview(CAL_SCENARIO_ENUM Id, P_IMAGE_SENSOR_SCENARIO_PARA_IN_STRUCT In, P_IMAGE_SENSOR_SCENARIO_PARA_OUT_STRUCT Out)
{
    OV5640Sensor.BandingFreq = (CAM_BANDING_50HZ == In->BandingFreq ? OV5640_50HZ : OV5640_60HZ);

    /* change to preview size output */
    OV5640Sensor.PvMode = KAL_TRUE;
    OV5640PvSetting();
    OV5640SetClock(OV5640_PV_INTERNAL_CLK);

    OV5640_TRACE("preview: %d fps", In->MaxVideoFrameRate);
    /* set preview frame rate range */
    switch (Id)
    {
    case CAL_SCENARIO_VIDEO:
        OV5640SetVideoFps(In->MaxVideoFrameRate);
        break;
    default:
        OV5640SetMaxFps(OV5640_FPS(30));
        OV5640SetMinFps(In->NightMode ? OV5640_FPS(5) : OV5640_FPS(10));

        /* roll back shutter&gain from capture state */
        if (OV5640Sensor.CapState)
        {
            OV5640WriteShutter(OV5640Sensor.Shutter);
            OV5640WriteGain(OV5640Sensor.Gain);
        }
    }

    /* misc setting */
    OV5640SetMirror(In->ImageMirror);
    OV5640NightMode(In->NightMode);

    /* change to preview state */
    OV5640Sensor.CapState = KAL_FALSE;

    /* enable ae/awb */
    OV5640AeEnable(KAL_TRUE);
    OV5640AwbEnable(KAL_TRUE);

    /* set grab window */
    Out->WaitStableFrameNum = 0;
    Out->GrabStartX = OV5640_PV_GRAB_START_X;
    Out->GrabStartY = OV5640_PV_GRAB_START_Y;
    Out->ExposureWindowWidth = OV5640_PV_GRAB_WIDTH;
    Out->ExposureWindowHeight = OV5640_PV_GRAB_HEIGHT;
}

/*************************************************************************
* FUNCTION
*   OV5640Capture
*
* DESCRIPTION
*   This function is the most important functions of (Init, Preview & Capture). 
*   1. Apply capture setting when capture size greatter then preview size, make sensor output 
*     full size, e.g. 1600x1200 for 2M sensor.
*   2. Increase the dummy pixels or derease pixel clock based on the digital zoom factor and
*    interpolation times.
*   3. Re-Calculate the shutter and sensor gain, to make the exposure value is same with preview
*   4. Configure the grab window based on sensor output.
*
* PARAMETERS
*   Id, In, Out
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640Capture(CAL_SCENARIO_ENUM Id, P_IMAGE_SENSOR_SCENARIO_PARA_IN_STRUCT In, P_IMAGE_SENSOR_SCENARIO_PARA_OUT_STRUCT Out)
{
    kal_uint32 PvClk, PvLineLength, CapShutter, CapLineLength, DummyPixel = 0;

    /* back up preview clock/linelength/shutter */
    PvClk = OV5640Sensor.InternalClock;
    PvLineLength = OV5640Sensor.LineLength;
    OV5640Sensor.Shutter = OV5640ReadShutter();
    OV5640Sensor.Gain = OV5640ReadGain();

    /* change to capture state */
    OV5640Sensor.CapState = KAL_TRUE;
    if (In->ImageTargetWidth <= OV5640_IMAGE_SENSOR_PV_WIDTH && In->ImageTargetHeight <= OV5640_IMAGE_SENSOR_PV_HEIGHT)
    {
        // TODO: add dummy pixel or reduce pclk until capture success
        {
#if (defined(DRV_ISP_YUV_BURST_MODE_SUPPORT) || defined(DRV_ISP_6276_SERIES)) /* MT6253/76 */
            /* no need reduce frame rate */
#elif (defined(DRV_ISP_MT6236_HW_SUPPORT)) /* MT6236 */
            if (In->ZoomFactor > 400) /* (4, 8]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
            else if (In->ZoomFactor > 200) /* (2, 4]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
            else if (In->ZoomFactor > 100) /* (1, 2]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
#elif (defined(DRV_ISP_6238_SERIES))
            if (In->ZoomFactor > 400) /* (4, 8]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
            else if (In->ZoomFactor > 200) /* (2, 4]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
            else if (In->ZoomFactor > 100) /* (1, 2]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
#elif (defined(DRV_ISP_6235_SERIES)) /* MT6235 */
            if (In->ZoomFactor > 400) /* (4, 8]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
            else if (In->ZoomFactor > 200) /* (2, 4]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
            else if (In->ZoomFactor > 100) /* (1, 2]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
#else
#error not verify yet
#endif
        }

        if (DummyPixel)
        {
            /* disable ae/awb */
            OV5640AeEnable(KAL_FALSE);
            OV5640AwbEnable(KAL_FALSE);

            /* set dummy pixel */
            if (PvLineLength - OV5640_PV_PERIOD_PIXEL_NUMS > DummyPixel)
            {
                DummyPixel = PvLineLength - OV5640_PV_PERIOD_PIXEL_NUMS;
            }
            OV5640SetDummy(DummyPixel, 0);

            /* shutter translation, OV5640Sensor.InternalClock >> 14 & PvClk >> 14 to avoid data overflow */
            CapShutter = (OV5640Sensor.Shutter * (OV5640Sensor.InternalClock >> 14) + (PvClk >> 15)) / (PvClk >> 14);
            CapShutter = (CapShutter * PvLineLength + (OV5640Sensor.LineLength >> 1)) / OV5640Sensor.LineLength;

            /* write shutter */
            OV5640WriteShutter(CapShutter);

            Out->WaitStableFrameNum = OV5640_CAPTURE_DELAY_FRAME;
        }
        else
        {
            Out->WaitStableFrameNum = 0;
        }

        /* set grab window */
        Out->GrabStartX = OV5640_PV_GRAB_START_X;
        Out->GrabStartY = OV5640_PV_GRAB_START_Y;
        Out->ExposureWindowWidth = OV5640_PV_GRAB_WIDTH;
        Out->ExposureWindowHeight = OV5640_PV_GRAB_HEIGHT;
    }
    else
    {
        /* disable ae/awb */
        OV5640AeEnable(KAL_FALSE);
        OV5640AwbEnable(KAL_FALSE);

        /* change to full size output */
        OV5640Sensor.PvMode = KAL_FALSE;
        OV5640CapSetting();
        OV5640SetClock(OV5640_CAP_INTERNAL_CLK);

        // TODO: add dummy pixel or reduce pclk until capture success

#if (defined(DRV_ISP_YUV_BURST_MODE_SUPPORT) || defined(DRV_ISP_6276_SERIES)) /* MT6253/76 */
            /* no need reduce frame rate */
#elif (defined(DRV_ISP_MT6236_HW_SUPPORT)) /* MT6236 */
            if (In->ZoomFactor > 400) /* (4, 8]x zoom */
            {
                DummyPixel = 250;
                OV5640SetClock(OV5640_CAP_INTERNAL_CLK_8X);
            }
            else if (In->ZoomFactor > 200) /* (2, 4]x zoom */
            {
                DummyPixel = 512;
                OV5640SetClock(OV5640_CAP_INTERNAL_CLK_4X);
            }
            else if (In->ZoomFactor > 100) /* (1, 2]x zoom */
            {
                DummyPixel = 0;
                OV5640SetClock(OV5640_CAP_INTERNAL_CLK_2X);
            }
#elif (defined(DRV_ISP_6238_SERIES))
            if (In->ZoomFactor > 400) /* (4, 8]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
            else if (In->ZoomFactor > 200) /* (2, 4]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
            else if (In->ZoomFactor > 100) /* (1, 2]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
#elif (defined(DRV_ISP_6235_SERIES)) /* MT6235 */
            if (In->ZoomFactor > 400) /* (4, 8]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
            else if (In->ZoomFactor > 200) /* (2, 4]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
            else if (In->ZoomFactor > 100) /* (1, 2]x zoom */
            {
                DummyPixel = 0;
                /* please reduce pclk if dummy pixel overflow */
                /* OV5640SetClock(~); */
            }
#else
#error not verify yet
#endif


        /* set dummy pixel */
        CapLineLength = OV5640Sensor.InternalClock * OV5640_FPS(1) / (OV5640_FULL_PERIOD_LINE_NUMS * In->MaxVideoFrameRate);
        if (CapLineLength < OV5640_FULL_PERIOD_PIXEL_NUMS)
        {
            CapLineLength = OV5640_FULL_PERIOD_PIXEL_NUMS;
        }
        if (CapLineLength > OV5640_MAX_CAP_LINELENGTH) /* register limitation */
        {
            OV5640_TRACE("caplinelength: %d, capframerate: %d overflow!!!", CapLineLength, In->MaxVideoFrameRate);
            CapLineLength = OV5640_MAX_CAP_LINELENGTH;
        }
        if (CapLineLength - OV5640_FULL_PERIOD_PIXEL_NUMS > DummyPixel)
        {
            DummyPixel = CapLineLength - OV5640_FULL_PERIOD_PIXEL_NUMS;
        }
        OV5640SetDummy(DummyPixel, 0);

        /* shutter translation, OV5640Sensor.InternalClock >> 14 & PvClk >> 14 to avoid data overflow */
        CapShutter = (OV5640Sensor.Shutter * (OV5640Sensor.InternalClock >> 14) + (PvClk >> 15)) / (PvClk >> 14);
        CapShutter = (CapShutter * PvLineLength + (OV5640Sensor.LineLength >> 1)) / OV5640Sensor.LineLength;

        /* write shutter */
        OV5640WriteShutter(CapShutter);

        /* set grab window */
        Out->WaitStableFrameNum = OV5640_CAPTURE_DELAY_FRAME;

        Out->GrabStartX = OV5640_FULL_GRAB_START_X;
        Out->GrabStartY = OV5640_FULL_GRAB_START_Y;
        Out->ExposureWindowWidth = OV5640_FULL_GRAB_WIDTH;
        Out->ExposureWindowHeight = OV5640_FULL_GRAB_HEIGHT;

    }
}

/*************************************************************************
* FUNCTION
*   OV5640DetectSensorId
*
* DESCRIPTION
*   This function detect sensor id
*
* PARAMETERS
*   None
*
* RETURNS
*   Sensor id
*
* LOCAL AFFECTED
*
*************************************************************************/
static kal_uint32 OV5640DetectSensorId(void)
{
    MM_ERROR_CODE_ENUM OV5640SensorClose(void);
    kal_uint32 SensorId;
    IMAGE_SENSOR_INDEX_ENUM InvIdx;
    kal_int8 i, j;

    switch (OV5640Sensor.SensorIdx)
    {
    case IMAGE_SENSOR_MAIN:
    case IMAGE_SENSOR_BAK1:
        InvIdx = IMAGE_SENSOR_SUB;
        break;
    default:
        InvIdx = IMAGE_SENSOR_MAIN;
        break;
    }
    for (i = 1; i >= 0; i--)
    {
        for (j = 1; j >= 0; j--)
        {
            CamRstPinCtrl(InvIdx, i);
            CamPdnPinCtrl(InvIdx, j);
            SensorId = OV5640PowerOn();
            OV5640SensorClose();
            if (OV5640_SENSOR_ID == SensorId)
            {
                return OV5640_SENSOR_ID;
            }
        }
    }
    return MM_ERROR_SENSOR_READ_ID_FAIL;
}

/*************************************************************************
* FUNCTION
*   OV5640InitOperationPara
*
* DESCRIPTION
*   This function set sensor operation para
*
* PARAMETERS
*   Para
*
* RETURNS
*   None
*
* LOCAL AFFECTED
*
*************************************************************************/
static void OV5640InitOperationPara(P_IMAGE_SENSOR_GET_INIT_OPERATION_PARA_STRUCT Para)
{
    Para->CaptureDelayFrame = 0; /* use WaitStableFrameNum instead of this */
    Para->PreviewDelayFrame = OV5640_PREVIEW_DELAY_FRAME;
    Para->PreviewDisplayWaitFrame = OV5640_FIRST_PREVIEW_DELAY_FRAME;

    // TODO: adjust YUV flashlight tunning parameter here
    Para->FlashlightPrestrobeFrame = 8; /* preview strobe keep on delay frame number */
    Para->FlashlightPrestrobeToRedeyeFrame = 1; /* preview strobe to redeye strobe delay frame */
    Para->FlashlightRedeyeStrobeFrame = 2; /* Redeye strobe keep on frame number */
    Para->FlashlightMainStrobeDelayFrame = 1; /* Main strobe on -> start viewfinder delay frame number, at least 1 */
}

/*************************************************************************
* FUNCTION
*   OV5640SensorOpen
*
* DESCRIPTION
*   This function read sensor id and init sensor
*
* PARAMETERS
*   None
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640SensorOpen(void)
{
    if (OV5640PowerOn() != OV5640_SENSOR_ID)
    {
        return MM_ERROR_SENSOR_READ_ID_FAIL;
    }
#ifdef OV5640_LOAD_FROM_T_FLASH
    if (!OV5640_Initialize_from_T_Flash()) /* for debug use. */
#endif
    {
        OV5640InitialSetting(); /* apply the sensor initial setting */
    }

    /* default setting */
    OV5640Sensor.BypassAe = KAL_FALSE; /* for panorama view */
    OV5640Sensor.BypassAwb = KAL_FALSE; /* for panorama view */
    OV5640Sensor.CapState = KAL_FALSE; /* preview state */
    OV5640Sensor.PvMode = KAL_TRUE; /* preview size output mode */
    OV5640Sensor.BandingFreq = OV5640_50HZ;
    OV5640Sensor.InternalClock = 1; /* will be update by setclock function */
    OV5640Sensor.Shutter = 1; /* default shutter 1 avoid divide by 0 */
    OV5640Sensor.Gain = 0x40; /* default gain 1x */
    OV5640Sensor.FrameLength = OV5640_PV_PERIOD_LINE_NUMS; /* will be update by setdummy function */
    OV5640Sensor.LineLength = OV5640_PV_PERIOD_PIXEL_NUMS; /* will be update by setdummy function */

    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640SensorFeatureCtrl
*
* DESCRIPTION
*   This function set sensor feature mode
*
* PARAMETERS
*   Id: scenario id
*   In: input parameter
*   Out: output parameter
*   OutLen: output parameter length
*   RealOutLen: real output parameter length
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640SensorFeatureCtrl(kal_uint32 Id, void *In, void *Out, kal_uint32 OutLen, kal_uint32 *RealOutLen)
{
    MM_ERROR_CODE_ENUM ErrCode = MM_ERROR_NONE;

    if (Id >= CAL_FEATURE_WEBCAM_BEGIN && Id <= CAL_FEATURE_WEBCAM_END)
    {
        return OV5640WebcamFeatureCtrl(Id, In, Out, OutLen, RealOutLen);
    }
    switch (Id)
    {
    /* query and set series */
    case CAL_FEATURE_CAMERA_BRIGHTNESS:
    case CAL_FEATURE_CAMERA_EV_VALUE:
        ErrCode = OV5640Ev(In, Out);
        break;
    case CAL_FEATURE_CAMERA_CONTRAST:
        ErrCode = OV5640Contrast(In, Out);
        break;
    case CAL_FEATURE_CAMERA_SATURATION:
        ErrCode = OV5640Saturation(In, Out);
        break;
    case CAL_FEATURE_CAMERA_SHARPNESS:
        ErrCode = OV5640Sharpness(In, Out);
        break;
    case CAL_FEATURE_CAMERA_WB:
        ErrCode = OV5640Wb(In, Out);
        break;
    case CAL_FEATURE_CAMERA_IMAGE_EFFECT:
        ErrCode = OV5640Effect(In, Out);
        break;
    case CAL_FEATURE_CAMERA_STILL_CAPTURE_SIZE:
        ErrCode = OV5640StillCaptureSize(In, Out);
        break;
    case CAL_FEATURE_CAMERA_BANDING_FREQ:
        ErrCode = OV5640Banding(In, Out);
        break;
    case CAL_FEATURE_CAMERA_SCENE_MODE:
        ErrCode = OV5640SceneMode(KAL_TRUE, In, Out);
        break;
    case CAL_FEATURE_CAMERA_VIDEO_SCENE_MODE:
        ErrCode = OV5640SceneMode(KAL_FALSE, In, Out);
        break;
    case CAL_FEATURE_CAMERA_HUE:
    case CAL_FEATURE_CAMERA_GAMMA:
        ErrCode = MM_ERROR_SENSOR_FEATURE_NOT_SUPPORT;
        break;

    /* get info series */
    case IMAGE_SENSOR_FEATURE_GET_SENSOR_INFO:
        OV5640GetSensorInfo(Out);
        break;
    case IMAGE_SENSOR_FEATURE_GET_SENSOR_ID:
        ((P_IMAGE_SENSOR_COMM_DATA_STRUCT)Out)->FeatureValue = OV5640DetectSensorId();
        break;
    case IMAGE_SENSOR_FEATURE_GET_SENSOR_FRAME_RATE:
        ((P_IMAGE_SENSOR_COMM_DATA_STRUCT)Out)->FeatureValue = \
        OV5640Sensor.InternalClock * OV5640_FPS(1) / (OV5640Sensor.LineLength * OV5640Sensor.FrameLength);
        break;
    case IMAGE_SENSOR_FEATURE_GET_INIT_OPERATION_PARA:
        OV5640InitOperationPara(Out);
        break;
    case IMAGE_SENSOR_FEATURE_GET_HW_DEPENDENT_SETTING:
        CamGetHWInfo(OV5640Sensor.SensorIdx, Out);
        break;
#if defined (__AUTO_SCENE_DETECT_SUPPORT__)
    case IMAGE_SENSOR_FEATURE_GET_EV_AWB_REF:
        OV5640GetEvAwbRef(Out);
        break;
    case IMAGE_SENSOR_FEATURE_GET_SHUTTER_GAIN_AWB_GAIN:
        OV5640GetCurAeAwbInfo(Out);
        break;
    case IMAGE_SENSOR_FEATURE_SET_SCENE_ENHANCE:
    {
        CAL_FEATURE_CTRL_STRUCT Para;

        Para.FeatureCtrlCode = CAL_FEATURE_SET_OPERATION;
        Para.FeatureSetValue = ((P_SENSOR_SCENE_ENHANCE_STRUCT)In)->SceneContrast;
        OV5640Contrast(&Para, NULL);
        Para.FeatureSetValue = ((P_SENSOR_SCENE_ENHANCE_STRUCT)In)->SceneSaturation;
        OV5640Saturation(&Para, NULL);
        Para.FeatureSetValue = ((P_SENSOR_SCENE_ENHANCE_STRUCT)In)->SceneSharpness;
        OV5640Sharpness(&Para, NULL);
        break;
    }
#endif

    /* set para series */
    case IMAGE_SENSOR_FEATURE_SET_SENSOR_POWER_DOWN:
        OV5640PowerDown();
        break;
    case IMAGE_SENSOR_FEATURE_SET_NVRAM_SENSOR_INFO:
        OV5640Sensor.NvramData = &(((nvram_camera_para_struct *)In)->SENSOR);
        break;
    case IMAGE_SENSOR_FEATURE_SET_CAMERA_SOURCE:
        OV5640Sensor.SensorIdx = ((P_IMAGE_SENSOR_SET_CAMERA_SOURCE_STRUCT)In)->ImageSensorIdx;
        break;
    case IMAGE_SENSOR_FEATURE_CTRL_NIGHTMODE: /* move to preview */
        break;
    case IMAGE_SENSOR_FEATURE_SET_AE_BYPASS:
        OV5640Sensor.BypassAe = (kal_bool)((P_IMAGE_SENSOR_COMM_DATA_STRUCT)In)->FeatureValue;
        OV5640AeEnable(OV5640Sensor.BypassAe ? KAL_FALSE : KAL_TRUE);
        break;
    case IMAGE_SENSOR_FEATURE_SET_AWB_BYPASS:
        OV5640Sensor.BypassAwb = (kal_bool)((P_IMAGE_SENSOR_COMM_DATA_STRUCT)In)->FeatureValue;
        OV5640AwbEnable(OV5640Sensor.BypassAwb ? KAL_FALSE : KAL_TRUE);
        break;

    /* jpeg support series */
    case CAL_FEATURE_CAMERA_DIGITAL_ZOOM:
        ErrCode = OV5640GetZoomInfo(In, Out);
        break;
    case IMAGE_SENSOR_FEATURE_GET_CAPTURE_FORMAT:
        OV5640GetCaptureFormat(In, Out);
        break;
    case IMAGE_SENSOR_FEATURE_GET_JPEG_INFO:
        ErrCode = OV5640ParseJpegData(In, Out);
        break;

    /* YUV AF support series */
    case CAL_FEATURE_CAMERA_AF_KEY:
        ErrCode = OV5640AfKey(In, Out);
        break;
    case CAL_FEATURE_CAMERA_AF_RANGE_CONTROL:
        OV5640AfRange(In, Out);
        break;
    case CAL_FEATURE_CAMERA_AF_OPERATION_MODE:
        OV5640AfOperation(In, Out);
        break;
    case CAL_FEATURE_CAMERA_GET_AF_ZONE:
        OV5640AfGetZone(In, Out);
        break;
    case CAL_FEATURE_CAMERA_AF_RESULT:
        OV5640AfGetResult(In, Out);
        break;

    /* YUV flash light support series */
    case CAL_FEATURE_CAMERA_FLASH_MODE:
        ErrCode = OV5640FlashMode(In, Out);
        break;
    case IMAGE_SENSOR_FEATURE_QUERY_YUV_CTRL_FLASHLIGHT_TRIGGER_MODE:
        ((P_IMAGE_SENSOR_COMM_DATA_STRUCT)Out)->FeatureValue = FLASHLIGHT_CONTINUOUS_MODE;
        break;
    case IMAGE_SENSOR_FEATURE_SET_YUV_CTRL_FLASHLIGHT_TRIGGER_MODE:
        break;
    case IMAGE_SENSOR_FEATURE_CTRL_FLASHLIGHT:
        FlashlightPowerOn(OV5640Sensor.SensorIdx, ((P_IMAGE_SENSOR_COMM_CTRL_STRUCT)In)->FeatureEnable);
        break;
    case IMAGE_SENSOR_FEATURE_YUV_CHECK_IF_TRIGGER_FLASHLIGHT:
        ((P_IMAGE_SENSOR_COMM_DATA_STRUCT)Out)->FeatureValue = OV5640FlashTriggerCheck();
        break;

    default:
        ErrCode = MM_ERROR_SENSOR_FEATURE_NOT_SUPPORT;
        break;
    }
    return ErrCode;
}

/*************************************************************************
* FUNCTION
*   OV5640SensorCtrl
*
* DESCRIPTION
*   This function set sensor scenario mode
*
* PARAMETERS
*   Id: scenario id
*   In/Out: parameter
*   OutLen: out parameter length
*   RealOutLen: real out parameter length
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640SensorCtrl(CAL_SCENARIO_ENUM Id, void *In, void *Out, kal_uint32 OutLen, kal_uint32 *RealOutLen)
{
    switch (Id)
    {
    case CAL_SCENARIO_CAMERA_PREVIEW:
    case CAL_SCENARIO_VIDEO:
    case CAL_SCENARIO_WEBCAM_PREVIEW:
    case CAL_SCENARIO_WEBCAM_CAPTURE:
        OV5640Preview(Id, In, Out);
        break;
    case CAL_SCENARIO_CAMERA_STILL_CAPTURE:
        OV5640Capture(Id, In, Out);
        break;
    default:
        break;
    }
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640SensorClose
*
* DESCRIPTION
*   This function is to turn off sensor module power.
*
* PARAMETERS
*   None
*
* RETURNS
*   Error code
*
* LOCAL AFFECTED
*
*************************************************************************/
static MM_ERROR_CODE_ENUM OV5640SensorClose(void)
{
    OV5640PowerDown();
    CisModulePowerOn(OV5640Sensor.SensorIdx, KAL_FALSE);
    CameraSccbClose(CAMERA_SCCB_SENSOR);
  
    return MM_ERROR_NONE;
}

/*************************************************************************
* FUNCTION
*   OV5640SensorFunc
*
* DESCRIPTION
*   This function get sensor function pointer
*
* PARAMETERS
*   Sensor function pointer
*
* RETURNS
*   Error code
*
* GLOBALS AFFECTED
*
*************************************************************************/
MM_ERROR_CODE_ENUM OV5640SensorFunc(P_IMAGE_SENSOR_FUNCTION_STRUCT *pfSensorFunc)
{
    static IMAGE_SENSOR_FUNCTION_STRUCT ImageSensorFuncOV5640 =
    {
        OV5640SensorOpen,
        OV5640SensorFeatureCtrl,
        OV5640SensorCtrl,
        OV5640SensorClose,
    };

    *pfSensorFunc = &ImageSensorFuncOV5640;
  
    return MM_ERROR_NONE;
}

#ifdef __OV5640_DEBUG_TRACE__
static kal_bool OV5640AtGetValue(char *Str, kal_uint32 *Data)
{
    extern int isdigit(int c);
    extern int isxdigit(int c);
    extern int tolower(int c);
    char CmdName[15];
    kal_uint8 TmpIdx = 0, Index = 3;
    kal_uint32 Value;

    while (Str[Index] != '=' && Str[Index] != 13)
    {
        CmdName[TmpIdx++] = Str[Index++];
    }
    CmdName[TmpIdx] = '\0';

    if (strcmp(CmdName, "DO"))
    {
        return KAL_FALSE;
    }
    Value = Data[0] = 0;
    while (1)
    {
        TmpIdx = Str[++Index];
        switch (TmpIdx)
        {
        case 13:
        case ',':
            Data[++Data[0]] = Value;
            if (Data[0] == 9 || TmpIdx == 13)
            {
                return KAL_TRUE;
            }
            Value = 0;
            break;
        default:
            if (isdigit(TmpIdx))
            {
                Value = Value * 16 + TmpIdx - '0';
            }
            else if (isxdigit(TmpIdx))
            {
                Value = Value * 16 + tolower(TmpIdx) - 'a' + 10;
            }
            else
            {
                return KAL_TRUE;
            }
            break;
        }
    }
}

kal_bool AtFuncTest(kal_char *Str)
{
    kal_uint32 Data[10];

    if (!OV5640AtGetValue(Str, Data))
    {
        return KAL_FALSE;
    }
    if (!Data[0])
    {
        return KAL_TRUE;
    }
    switch (Data[1])
    {
    case 0x00:
        {
            extern kal_uint32 IspCurrentFrameRate;

            OV5640_TRACE("Current Frame Rate: %d.%d fps", IspCurrentFrameRate / 10, IspCurrentFrameRate % 10);
        }
        break;
    case 0x02:
        OV5640_TRACE("Read BB Reg[%x] = %x", Data[2], DRV_Reg32(Data[2]));
        break;
    case 0x03:
        DRV_Reg32(Data[2]) = Data[3];
        OV5640_TRACE("Write BB Reg[%x] = %x", Data[2], DRV_Reg32(Data[2]));
        break;
    case 0x04:
        OV5640_TRACE("Read Sensor Reg[%x] = %x", Data[2], CamReadCmosSensor(Data[2]));
        break;
    case 0x05:
        CamWriteCmosSensor(Data[2], Data[3]);
        OV5640_TRACE("Write Sensor Reg[%x] = %x", Data[2], CamReadCmosSensor(Data[2]));
        break;
    case 0x06:
        CamWriteCmosSensor(Data[2], Data[3]);
        OV5640_TRACE("Read Sensor Reg[%x:%x] = %x", Data[3], Data[4], CamReadCmosSensor(Data[4]));
        break;
    case 0x07:
        CamWriteCmosSensor(Data[2], Data[3]);
        CamWriteCmosSensor(Data[4], Data[5]);
        CamWriteCmosSensor(Data[2], Data[3]);
        OV5640_TRACE("Write Sensor Reg[%x:%x] = %x", Data[3], Data[4], CamReadCmosSensor(Data[4]));
        break;
    case 0x08:
        OV5640AfSetCmd(Data[2]);
        break;
    case 0x09:
        //Data[4] = t[Data[2]];
        //t[Data[2]] = Data[3];
        //kal_print_string_trace(MOD_ENG, TRACE_INFO, "t[%d]: %d -> %d", Data[2], Data[4], t[Data[2]]);
        break;
    case 0x0A:
        {
            kal_uint32 i;

            for (i = 0; i < Data[3]; i++)
            {
                OV5640_TRACE("Read Sensor Reg[%x] = %x", Data[2] + i, CamReadCmosSensor(Data[2] + i));
                if (!(i % 200))
                {
                    kal_sleep_task(30);
                }
            }
        }
        break;
    case 0x0B:
        {
            kal_uint32 i;

            for (i = 0; i < Data[3]; i++)
            {
                OV5640_TRACE("Read BB Reg[%x] = %x", Data[2] + i * 4, DRV_Reg32(Data[2] + i * 4));
                if (!(i % 200))
                {
                    kal_sleep_task(30);
                }
            }
        }
        break;
    default:
        break;
    }
    return KAL_TRUE;
}
#endif

